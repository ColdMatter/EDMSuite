(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM4`Analysis`","SEDM4`EDMSuite`","SEDM4`Polarisation`","SEDM4`Database`","SEDM4`Blind`","SEDM4`Statistics`","NETLink`","JLink`"];


(* ::Input::Initialization:: *)
(*Helper functions*)
basis::usage="";
edmWaveform::usage="";
boolSign::usage="";

(*Functions to extract data from a block*)
integrateTOF::usage="Takes a block and integrates to TOF profiles for the specified detector. The Boolean parameter returnIntegral determines whether the returned values are the integrals (in V \[Mu]s) or the average values (in V).";
getAverageBG::usage="";
integrateTOFBackSubtract::usage="";

(*Functions to extract physical quantities from a demodulated block*)
cField::usage="cField[dblock_] returns the electric field applied in kV/cm.";
edmFactor::usage="edmFactor[dblock_] returns the factor used to convert the EDM channel values into a physical EDM in e.cm units.";
edmSign::usage="edmSign[dblock_] returns the sign of the edm given by the manual E and B states of the block.";
rawEDMWithErr::usage="rawEDMWithErr[dblock_] returns the uncorrected EDM as a TOF with errors of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(value\), \(i\)]\), \!\(\*SubscriptBox[\(error\), \(i\)]\)}...}.";
correctedEDMWithErr::usage="correctedEDMWithErr[dblock_] returns the corrected EDM as a TOF with errors of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(value\), \(i\)]\), \!\(\*SubscriptBox[\(error\), \(i\)]\)}...}.";
contrast::usage="contrast[dblock_] returns the contrast of the interferometer as a TOF with errors of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(value\), \(i\)]\), \!\(\*SubscriptBox[\(error\), \(i\)]\)}...}.";
edmSn::usage="edmSn[dblock_] returns the shot-noise-limited uncertainty in the EDM value as a TOF of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(shotNoiseUncertainty\), \(i\)]\)}...}.";
edmSnNoLaserBackground::usage="edmSnNoLaserBackground[dblock_] returns the shot-noise-limited uncertainty (without factoring in the laser scatter background) in the EDM value as a TOF of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(shotNoiseUncertainty\), \(i\)]\)}...}.";
snPPMPerChannel::usage="snPPMPerChannel[dblock_] returns the shot-noise-limited uncertainty in a typical channel in parts per million, in a TOF of the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(shotNoiseUncertainty\), \(i\)]\)}...}."

(*Main functions used to extract all quantities of interest for a demodulated block*)
extractPhysicalQuantities::usage="extractPhysicalQuantities[dblock_] takes a demodulated block and extracts the uncorrected and corrected edms, the contrast, and the shot-noise sensitivities for both the edm and the channels.";
extractSummaryData::usage="extractSummaryData[dblock_] takes a demodulated block and extracts the physical quantities, basic configuration data such as timestamps and manual states, as well as any channels of interest. Edit this function to add/remove channels of interest.";
correctBlock::usage="Not functional currently, but will be developed at a later date to correct for systematic shifts on a block-by-block basis.";


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
electronCharge=1.6022*10^-19;
bohrMagneton=9.274*10^-24;
hbar=1.05457*10^-34;
saturatedEffectiveField=26*10^9;
plateSpacing=1.2;
pmtCalibration = 510;


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
basis[bit_, length_] := Flatten[Table[ { Table[ 1, {2^(bit-1)}], Table[-1, {2^(bit-1)}]} , {length/ (2^bit)}]];
edmWaveform[code_]:= Module[{numWave},numWave=\!\(
\*UnderoverscriptBox[\(\[Product]\), \(i\  = \ 1\), \(Length[code]\)]\ \(If[\ code[[i]], \ basis[Length[code] - \ i + 1, \ 
\*SuperscriptBox[\(2\), \(Length[code]\)]], \ Table[1, {
\*SuperscriptBox[\(2\), \(Length[code]\)]}]]\)\);
(#==1)&/@numWave
];

boolSign[bool_]:=If[bool,1,-1]


(* ::Input::Initialization:: *)
integrateTOF[block_,detector_Integer,gateStart_Integer,gateEnd_Integer,returnIntegral_,detectorName_String]:=Module[{gatedData,gatePeriod,dat,cal},

dat=If[returnIntegral,
gatedData=block@GetTOFIntegralArray[detector,gateStart,gateEnd],
gatedData=block@GetTOFMeanArray[detector,gateStart,gateEnd]
];

cal=block@Points[0]@Shot@TOFs[detector]@Calibration;

{"name"->detectorName,"data"->dat,"calibration"->cal}
];


(* ::Input::Initialization:: *)
getAverageBG[block_,detector_,gateStart_,gateEnd_]:=Mean["data"/.integrateTOF[block,detector,gateStart,gateEnd,False,""]]


(* ::Input::Initialization:: *)
integrateTOFBackSubtract[block_,detector_,gateStart_,gateEnd_,bgStart_,bgEnd_,name_]:=Module[{integral,bg,newData,subbedBG},
integral=integrateTOF[block,detector,gateStart,gateEnd,True,name];
bg=getAverageBG[block,detector,bgStart,bgEnd];
subbedBG=(bg*(gateEnd-gateStart));
newData=("data"/.integral)-subbedBG;
{"name"->name,"data"->newData,"calibration"->("calibration"/.integral),"subtractedBG"->subbedBG}
]


(* ::Input::Initialization:: *)
cField[dblock_]:=(dblock@Config@Settings["ePlus"] - dblock@Config@Settings["eMinus"])/plateSpacing


(* ::Input::Initialization:: *)
edmFactor[dblock_]:= Module[{dbStep,magCal},

dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];

1/electronCharge (bohrMagneton * dbStep*magCal*10^-9)1/(saturatedEffectiveField polarisationFactor[Abs[cField[dblock]]/1000])
]


(* ::Input::Initialization:: *)
edmSign[dblock_]:= boolSign[dblock@Config@Settings["eState"]] boolSign[dblock@Config@Settings["bState"]]


(* ::Input::Initialization:: *)
rawEDMWithErr[dblock_]:={#[[1]],edmFactor[dblock](#[[2]]+edmSign[dblock]SEDM4`Blind`blindEDM),edmFactor[dblock]#[[3]]}&/@getTOFChannel["EDMDB","asymmetry",dblock]


(* ::Input::Initialization:: *)
correctedEDMWithErr[dblock_]:={#[[1]],edmFactor[dblock](#[[2]]+edmSign[dblock]SEDM4`Blind`blindEDM),edmFactor[dblock]#[[3]]}&/@getTOFChannel["EDMCORRDB","asymmetry",dblock]


(* ::Input::Initialization:: *)
counts[dblock_,detector_]:=getTOFChannelValues[{"SIG"},detector,dblock]*pmtCalibration(*in MHz/V*)*10(*the resolution of the TOF is 10\[Mu]s*)


(* ::Input::Initialization:: *)
asymmetrySnWithLaserBackground[sTop_,sBot_,sTopbg_,sBotbg_]:=(4sTop sBot^2+4sBot sTop^2+4sBotbg sTop^2+4 sTopbg sBot^2)/(sTop+sBot)^4


(* ::Input::Initialization:: *)
asymmetrySnNoLaserBackground[sTop_,sBot_]:=(4sTop sBot^2+4sBot sTop^2)/(sTop+sBot)^4


(* ::Input::Initialization:: *)
edmSn[dblock_]:=Module[{topCounts,bottomCounts,topLaserScatter,bottomLaserScatter,dbChannel},
topCounts=getTOFChannelValues[{"SIG"},"topProbeNoBackground",dblock]*pmtCalibration(*in MHz/V*)*10(*the resolution of the TOF is 10\[Mu]s*);
bottomCounts=getTOFChannelValues[{"SIG"},"bottomProbeScaled",dblock]*pmtCalibration*10;
topLaserScatter=getPointChannelValue[{"SIG"},"TopDetectorBackground",dblock]*pmtCalibration*10;
bottomLaserScatter=getPointChannelValue[{"SIG"},"BottomDetectorBackground",dblock]*pmtCalibration*10;
dbChannel=getTOFChannelValues[{"DB"},"asymmetry",dblock];
Transpose[{getTOFChannelTimes[{"DB"},"asymmetry",dblock],edmFactor[dblock]Sqrt[asymmetrySnWithLaserBackground[topCounts,bottomCounts,topLaserScatter,bottomLaserScatter]/(dblock@Config@Settings["numberOfPoints"]*dbChannel^2)]}]
]


(* ::Input::Initialization:: *)
edmSnNoLaserBackground[dblock_]:=Module[{topCounts,bottomCounts,dbChannel},
topCounts=getTOFChannelValues[{"SIG"},"topProbeNoBackground",dblock]*pmtCalibration(*in MHz/V*)*10(*the resolution of the TOF is 10\[Mu]s*);
bottomCounts=getTOFChannelValues[{"SIG"},"bottomProbeScaled",dblock]*pmtCalibration*10;
dbChannel=getTOFChannelValues[{"DB"},"asymmetry",dblock];
Transpose[{getTOFChannelTimes[{"DB"},"asymmetry",dblock],edmFactor[dblock]Sqrt[asymmetrySn[topCounts,bottomCounts]/(dblock@Config@Settings["numberOfPoints"]*dbChannel^2)]}]
]


(* ::Input::Initialization:: *)
snPPMPerChannel[dblock_]:=Module[{topCounts,bottomCounts,topLaserScatter,bottomLaserScatter},
topCounts=getTOFChannelValues[{"SIG"},"topProbeNoBackground",dblock]*pmtCalibration(*in MHz/V*)*10(*the resolution of the TOF is 10\[Mu]s*);
bottomCounts=getTOFChannelValues[{"SIG"},"bottomProbeScaled",dblock]*pmtCalibration*10;
topLaserScatter=getPointChannelValue[{"SIG"},"TopDetectorBackground",dblock]*pmtCalibration*10;
bottomLaserScatter=getPointChannelValue[{"SIG"},"BottomDetectorBackground",dblock]*pmtCalibration*10;

Transpose[{getTOFChannelTimes[{"DB"},"asymmetry",dblock],10^6 Sqrt[asymmetrySnWithLaserBackground[topCounts,bottomCounts,topLaserScatter,bottomLaserScatter]/dblock@Config@Settings["numberOfPoints"]]}]
]


(* ::Input::Initialization:: *)
contrast[dblock_]:= Module[{dbStep,magCal,interferometerLength,phaseStep},
dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];
interferometerLength=Check[dblock@Config@Settings["rf2CentreTime"]-dblock@Config@Settings["rf1CentreTime"],800]*10^-6;
phaseStep=(bohrMagneton*dbStep*magCal*10^-9*interferometerLength)/hbar;

{#[[1]],#[[2]]/(2phaseStep),#[[3]]/(2 phaseStep)}&/@getTOFChannel[{"DB"},"asymmetry",dblock]
]


(* ::Input::Initialization:: *)
extractPhysicalQuantities[dblock_]:=
{"rawEDMWithErr"->rawEDMWithErr[dblock],
"signedEDMWithErr"->edmSign[dblock] rawEDMWithErr[dblock],
"correctedEDMWithErr"->correctedEDMWithErr[dblock],
"signedCorrectedEDMWithErr"->edmSign[dblock] correctedEDMWithErr[dblock],
"contrast"->contrast[dblock],
"edmSn"->edmSn[dblock],
"edmSnNoLaserBackground"->edmSnNoLaserBackground[dblock],
"snPPMPerChannel"->snPPMPerChannel[dblock]}


(* ::Input::Initialization:: *)
extractSummaryData[dbl_]:=Join[extractPhysicalQuantities[dbl],{
"bState"->dbl@Config@Settings["bState"],
"cluster"->dbl@Config@Settings["cluster"],
"clusterIndex"->dbl@Config@Settings["clusterIndex"],
"eState"->dbl@Config@Settings["eState"],
"rfState"->dbl@Config@Settings["rfState"],
"mwState"->dbl@Config@Settings["mwState"],
"ePlus"->dbl@Config@Settings["ePlus"],
"eMinus"->dbl@Config@Settings["eMinus"],
"timeStamp"->dbl@TimeStamp@Ticks,
"hour"->dbl@TimeStamp@Hour
}
]


(* ::Input::Initialization:: *)
(*extractSummaryData[dbl_,abl_,gated_]:=Join["analysisResults"/.abl,{
"EMag"\[Rule]getChannel[{"E"},"magnetometer",dbl,gated],
"SIGMag"\[Rule]getChannel[{"SIG"},"magnetometer",dbl,gated],
"BMag"\[Rule]getChannel[{"B"},"magnetometer",dbl,gated],
"EMagErr"\[Rule]getError[{"E"},"magnetometer",dbl,gated],
"SIGMagErr"\[Rule]getError[{"SIG"},"magnetometer",dbl,gated],
"BMagErr"\[Rule]getError[{"B"},"magnetometer",dbl,gated],
"BDBMag"\[Rule]getChannel[{"B","DB"},"magnetometer",dbl,gated],
"BDBMagErr"\[Rule]getError[{"B","DB"},"magnetometer",dbl,gated],

"PhaseLockFrequency"\[Rule]getChannel[{"SIG"},"PhaseLockFrequency",dbl,gated],

"ENorthCurrent"\[Rule]getChannel[{"E"},"NorthCurrent",dbl,gated],
"ESouthCurrent"\[Rule]getChannel[{"E"},"SouthCurrent",dbl,gated],
"ENorthCurrentErr"\[Rule]getError[{"E"},"NorthCurrent",dbl,gated],
"ESouthCurrentErr"\[Rule]getError[{"E"},"SouthCurrent",dbl,gated],

"cSIGtop"->getChannel[{"SIG"},"topProbeNoBackground",dbl,gated],
"cSIGtopErr"->getError[{"SIG"},"topProbeNoBackground",dbl,gated],
"cSIGbottom"->getChannel[{"SIG"},"bottomProbeScaled",dbl,gated],
"cSIGbottomErr"->getError[{"SIG"},"bottomProbeScaled",dbl,gated],
"cLaserBackgroundtop"->getChannel[{"SIG"},"TopDetectorBackground",dbl,gated],
"cLaserBackgroundtopErr"->getError[{"SIG"},"TopDetectorBackground",dbl,gated],
"cLaserBackgroundbottom"->getChannel[{"SIG"},"BottomDetectorBackground",dbl,gated],
"cLaserBackgroundbottomErr"->getError[{"SIG"},"BottomDetectorBackground",dbl,gated],

"cRF1F"\[Rule](getChannel[{"RF1F"},"asymmetry",dbl,gated]),
"cRF2F"\[Rule](getChannel[{"RF2F"},"asymmetry",dbl,gated]),
"cRF1A"\[Rule](getChannel[{"RF1A"},"asymmetry",dbl,gated]),
"cRF2A"\[Rule](getChannel[{"RF2A"},"asymmetry",dbl,gated]),
"cRF1FErr"\[Rule](getError[{"RF1F"},"asymmetry",dbl,gated]),
"cRF2FErr"\[Rule](getError[{"RF2F"},"asymmetry",dbl,gated]),
"cRF1AErr"\[Rule](getError[{"RF1A"},"asymmetry",dbl,gated]),
"cRF2AErr"\[Rule](getError[{"RF2A"},"asymmetry",dbl,gated]),

"cRF1FDB"\[Rule](getChannel[{"RF1F","DB"},"asymmetry",dbl,gated]),
"cRF2FDB"\[Rule](getChannel[{"RF2F","DB"},"asymmetry",dbl,gated]),
"cRF1FE"\[Rule](getChannel[{"RF1F","E"},"asymmetry",dbl,gated]),
"cRF2FE"\[Rule](getChannel[{"RF2F","E"},"asymmetry",dbl,gated]),
"cRF1AE"\[Rule](getChannel[{"RF1A","E"},"asymmetry",dbl,gated]),
"cRF2AE"\[Rule](getChannel[{"RF2A","E"},"asymmetry",dbl,gated]),
"cRF1AB"\[Rule](getChannel[{"RF1A","B"},"asymmetry",dbl,gated]),
"cRF2AB"\[Rule](getChannel[{"RF2A","B"},"asymmetry",dbl,gated]),
"cRF1FEDB"\[Rule](getChannel[{"RF1F","E","DB"},"asymmetry",dbl,gated]),
"cRF2FEDB"\[Rule](getChannel[{"RF2F","E","DB"},"asymmetry",dbl,gated]),
"cRF1FDBErr"\[Rule](getError[{"RF1F","DB"},"asymmetry",dbl,gated]),
"cRF2FDBErr"\[Rule](getError[{"RF2F","DB"},"asymmetry",dbl,gated]),
"cRF1FEErr"\[Rule](getError[{"RF1F","E"},"asymmetry",dbl,gated]),
"cRF2FEErr"\[Rule](getError[{"RF2F","E"},"asymmetry",dbl,gated]),
"cRF1AEErr"\[Rule](getError[{"RF1A","E"},"asymmetry",dbl,gated]),
"cRF2AEErr"\[Rule](getError[{"RF2A","E"},"asymmetry",dbl,gated]),
"cRF1ABErr"\[Rule](getError[{"RF1A","B"},"asymmetry",dbl,gated]),
"cRF2ABErr"\[Rule](getError[{"RF2A","B"},"asymmetry",dbl,gated]),
"cRF1FEDBErr"\[Rule](getError[{"RF1F","E","DB"},"asymmetry",dbl,gated]),
"cRF2FEDBErr"\[Rule](getError[{"RF2F","E","DB"},"asymmetry",dbl,gated]),

"cE"\[Rule]getChannel[{"E"},"asymmetry",dbl,gated],
"cEErr"\[Rule]getError[{"E"},"asymmetry",dbl,gated],
"cEB"\[Rule]getChannel[{"B","E"},"asymmetry",dbl,gated],
"cEBErr"\[Rule]getError[{"B","E"},"asymmetry",dbl,gated],
"cEBDB"\[Rule]getChannel[{"B","E","DB"},"asymmetry",dbl,gated],
"cEBDBErr"\[Rule]getError[{"B","E","DB"},"asymmetry",dbl,gated],
"cDB"\[Rule]getChannel[{"DB"},"asymmetry",dbl,gated],
"cDBErr"\[Rule]getError[{"DB"},"asymmetry",dbl,gated],
"cB"\[Rule]getChannel[{"B"},"asymmetry",dbl,gated],
"cBErr"\[Rule]getError[{"B"},"asymmetry",dbl,gated],
"cEDB"\[Rule]getChannel[{"E","DB"},"asymmetry",dbl,gated],
"cEDBErr"\[Rule]getError[{"E","DB"},"asymmetry",dbl,gated],
"cBDB"\[Rule]getChannel[{"B","DB"},"asymmetry",dbl,gated],
"cBDBErr"\[Rule]getError[{"B","DB"},"asymmetry",dbl,gated],

"edmFactor"\[Rule]edmFactor[dbl],

"Pi"\[Rule]getChannel[{"PI"},"asymmetry",dbl,gated],
(*"LF1"\[Rule]getChannel[{"LF1"},"asymmetry",dbl,gated],
"LF1Err"\[Rule]getError[{"LF1"},"asymmetry",dbl,gated],
"LF1B"\[Rule]getChannel[{"LF1","B"},"asymmetry",dbl,gated],
"LF1BErr"\[Rule]getError[{"LF1","B"},"asymmetry",dbl,gated],*)

"phaseScramblerV"\[Rule]dbl@Config@Settings["phaseScramblerV"],
"bState"\[Rule]dbl@Config@Settings["bState"],
"cluster"\[Rule]dbl@Config@Settings["cluster"],
"clusterIndex"\[Rule]dbl@Config@Settings["clusterIndex"],
"eState"\[Rule]dbl@Config@Settings["eState"],
"rfState"\[Rule]dbl@Config@Settings["rfState"],
"mwState"\[Rule]dbl@Config@Settings["mwState"],
"ePlus"\[Rule]dbl@Config@Settings["ePlus"],
"eMinus"\[Rule]dbl@Config@Settings["eMinus"],
"timeStamp"\[Rule]dbl@TimeStamp@Ticks,
"hour"\[Rule]dbl@TimeStamp@Hour,

"rf1Step"\[Rule]dbl@Config@GetModulationByName["RF1F"]@PhysicalStep,
"rf2Step"\[Rule]dbl@Config@GetModulationByName["RF2F"]@PhysicalStep,
"rf1fCentre"\[Rule]dbl@Config@GetModulationByName["RF1F"]@PhysicalCentre,
"rf2fCentre"\[Rule]dbl@Config@GetModulationByName["RF2F"]@PhysicalCentre,
"rf1Power"\[Rule]dbl@Config@GetModulationByName["RF1A"]@PhysicalCentre,
"rf2Power"\[Rule]dbl@Config@GetModulationByName["RF2A"]@PhysicalCentre,
"BiasC"\[Rule]dbl@Config@Settings["bBiasV"],
"BStep"\[Rule]dbl@Config@GetModulationByName["B"]@PhysicalStep,
(*"LF1PhysicalCentre"\[Rule]If[#\[Equal]0,1547,#]&[(dbl@Config@GetModulationByName["LF1"]@PhysicalCentre)],*)

"BDB"\[Rule]getChannel["BDB","asymmetry",dbl,gated],
"BDBErr"\[Rule]getError["BDB","asymmetry",dbl,gated],
"RF1FDB"\[Rule]getChannel["RF1FDB","asymmetry",dbl,gated],
"RF1FDBErr"\[Rule]getError["RF1FDB","asymmetry",dbl,gated],
"RF2FDB"\[Rule]getChannel["RF2FDB","asymmetry",dbl,gated],
"RF2FDBErr"\[Rule]getError["RF2FDB","asymmetry",dbl,gated],
"RF1FDBDB"\[Rule]getChannel["RF1FDBDB","asymmetry",dbl,gated],
"RF1FDBDBErr"\[Rule]getError["RF1FDBDB","asymmetry",dbl,gated],
"RF2FDBDB"\[Rule]getChannel["RF2FDBDB","asymmetry",dbl,gated],
"RF2FDBDBErr"\[Rule]getError["RF2FDBDB","asymmetry",dbl,gated],
"ERF1FDB"\[Rule]getChannel["ERF1FDB","asymmetry",dbl,gated],
"ERF1FDBErr"\[Rule]getError["ERF1FDB","asymmetry",dbl,gated],
"ERF2FDB"\[Rule]getChannel["ERF2FDB","asymmetry",dbl,gated],
"ERF2FDBErr"\[Rule]getChannel["ERF2FDB","asymmetry",dbl,gated],
"ERF1FDBDB"\[Rule]getChannel["ERF1FDBDB","asymmetry",dbl,gated],
"ERF1FDBDBErr"\[Rule]getChannel["ERF1FDBDB","asymmetry",dbl,gated],
"ERF2FDBDB"\[Rule]getChannel["ERF2FDBDB","asymmetry",dbl,gated],
"ERF2FDBDBErr"\[Rule]getError["ERF2FDBDB","asymmetry",dbl,gated],
"BRF1FCORRDB"\[Rule]getChannel["BRF1FCORRDB","asymmetry",dbl,gated],
"BRF1FCORRDBErr"\[Rule]getError["BRF1FCORRDB","asymmetry",dbl,gated],
"BRF2FCORRDB"\[Rule]getChannel["BRF2FCORRDB","asymmetry",dbl,gated],
"BRF2FCORRDBErr"\[Rule]getError["BRF2FCORRDB","asymmetry",dbl,gated]
}
]*)


(* ::Input::Initialization:: *)
correctBlock[summaryData_,wiggleSlope_,wiggleSlopeDB_,bCorrectionSlope_,rf1PhaseSlope_,rf2PhaseSlope_,offsetCorrection_]:=Module[{wiggleCorr,wiggleCorrDB,bCorr,rf1PhaseCorr,rf2PhaseCorr,fullyCorrectedBlockEDM},

wiggleCorr=wiggleSlope ("RF1FDBNL"/.summaryData)[[1]];
wiggleCorrDB=wiggleSlopeDB ("RF1FDBDBNL"/.summaryData)[[1]];
bCorr=bCorrectionSlope("E"/.#)boolSign["eState"/.#]&[summaryData];
rf1PhaseCorr=rf1PhaseSlope("edmFactor"/.#)(1/("rf1Step"/.#))First[(boolSign["bState"/.#]("BRF1FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF1FDBNL"/.#))]&[summaryData];
rf2PhaseCorr=rf2PhaseSlope("edmFactor"/.#)(1/("rf2Step"/.#))First[(boolSign["bState"/.#]("BRF2FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF2FDBNL"/.#))]&[summaryData];

fullyCorrectedBlockEDM=("signedCorrectedEDMNLNormed"/.summaryData)-(wiggleCorr+wiggleCorrDB)/2-bCorr-rf1PhaseCorr-rf2PhaseCorr-offsetCorrection;

Join[summaryData,{"wiggleCorr"->wiggleCorr,"wiggleCorrDB"->wiggleCorrDB,"bCorr"->bCorr,"rf1PhaseCorr"->rf1PhaseCorr,"rf2PhaseCorr"->rf2PhaseCorr,"offsetCorrection"->offsetCorrection,"fullyCorrectedBlockEDM"->fullyCorrectedBlockEDM}]
]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
