(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM4`Analysis`","SEDM4`EDMSuite`","SEDM4`Polarisation`","SEDM4`Database`","SEDM4`Blind`","SEDM4`Statistics`","NETLink`","JLink`"];


(* ::Input::Initialization:: *)
weightedMean::usage="Takes  a list of {value, error} pairs and calculates the weighted mean.";
integrateTOF::usage="Takes a block and integrates to TOF profiles for the specified detector. The Boolean parameter returnIntegral determines whether the returned values are the integrals (in V \[Mu]s) or the average values (in V).";
getAverageBG::usage="";
getPulseTiming::usage="";
getGateTiming::usage="";
integrateTOFBackSubtract::usage="";
extractNoiseData::usage="";
getChannelNoisePPM::usage="";
analyseBlock::usage="This function take a block and an extraction function and analyses the block.The extraction function is applied to the block and is expected to return a list of detectorDatas.The detector data is format is defined by integrateTOF.This is the usual way to generate detector data,but other ways can be plugged in if you like-for instance extracting data from the single point values instead of the TOFs.";
generatePulsedRFGates::usage="Calculates the correct gates to exclude molecules more than a given distance from the guard plate centres. The centres are in microseconds, the keep lengths in m. Molecules are selected symmetrically around the centre position. The offset parameter is to deal with a bug in the acquisition software before September 2005. If in doubt, it should be set to zero.";

basis::usage="";
edmWaveform::usage="";
boolSign::usage="";
extractPhysicalQuantities::usage="";

cField::usage="";
edmFactor::usage="";
edmSign::usage="";
rawEDM::usage="";
rawEDMErr::usage="";
correctedEDM::usage="";
correctedEDMErr::usage="";
counts::usage="";
contrast::usage="";
sn::usage="";

extractSummaryData::usage="";
correctBlock::usage="";


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
electronCharge=1.6022*10^-19;
bohrMagneton=9.274*10^-24;
hbar=1.05457*10^-34;
saturatedEffectiveField=26*10^9;
plateSpacing=1.2;
curveHalfWidthCurrent= 0.647  (*1260 us 0.49265*);(*long machine 0.5362*)(*Short Machine 0.665*) (*should be half the ideal DB step*);

kMachineLength=1.3;
kRF1Ratio=1.103*2.31;
kRF2Ratio=1.103;


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
basis[bit_, length_] := Flatten[Table[ { Table[ 1, {2^(bit-1)}], Table[-1, {2^(bit-1)}]} , {length/ (2^bit)}]];
edmWaveform[code_]:= Module[{numWave},numWave=\!\(
\*UnderoverscriptBox[\(\[Product]\), \(i\  = \ 1\), \(Length[code]\)]\ \(If[\ code[[i]], \ basis[Length[code] - \ i + 1, \ 
\*SuperscriptBox[\(2\), \(Length[code]\)]], \ Table[1, {
\*SuperscriptBox[\(2\), \(Length[code]\)]}]]\)\);
(#==1)&/@numWave
];

boolSign[bool_]:=If[bool,1,-1]


(* ::Input::Initialization:: *)
integrateTOF[block_,detector_Integer,gateStart_Integer,gateEnd_Integer,returnIntegral_,detectorName_String]:=Module[{gatedData,gatePeriod,dat,cal},

dat=If[returnIntegral,
gatedData=block@GetTOFIntegralArray[detector,gateStart,gateEnd],
gatedData=block@GetTOFMeanArray[detector,gateStart,gateEnd]
];

cal=block@Points[0]@Shot@TOFs[detector]@Calibration;

{"name"->detectorName,"data"->dat,"calibration"->cal}
];


(* ::Input::Initialization:: *)
getAverageBG[block_,detector_,gateStart_,gateEnd_]:=Mean["data"/.integrateTOF[block,detector,gateStart,gateEnd,False,""]]


(* ::Input::Initialization:: *)
integrateTOFBackSubtract[block_,detector_,gateStart_,gateEnd_,bgStart_,bgEnd_,name_]:=Module[{integral,bg,newData,subbedBG},
integral=integrateTOF[block,detector,gateStart,gateEnd,True,name];
bg=getAverageBG[block,detector,bgStart,bgEnd];
subbedBG=(bg*(gateEnd-gateStart));
newData=("data"/.integral)-subbedBG;
{"name"->name,"data"->newData,"calibration"->("calibration"/.integral),"subtractedBG"->subbedBG}
]


(* ::Input::Initialization:: *)
cField[dblock_]:=(dblock@Config@Settings["ePlus"] - dblock@Config@Settings["eMinus"])/plateSpacing


(* ::Input::Initialization:: *)
edmFactor[dblock_]:= Module[{dbStep,magCal},

dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];

1/electronCharge (bohrMagneton * dbStep*magCal*10^-9)1/(saturatedEffectiveField polarisationFactor[Abs[cField[dblock]]/1000])
]


(* ::Input::Initialization:: *)
edmSign[dblock_]:= boolSign[dblock@Config@Settings["eState"]] boolSign[dblock@Config@Settings["bState"]]


(* ::Input::Initialization:: *)
rawEDM[dblock_,gated_]:=If[gated,
(edmFactor[dblock] getGatedChannel["EDMDB","asymmetry",dblock])+edmSign[dblock]SEDM3`Blind`blindEDM,
Transpose[getTOFChannelTimes["EDMDB","asymmetry",dblock],(edmFactor[dblock] getTOFChannelData["EDMDB","asymmetry",dblock])+edmSign[dblock]SEDM3`Blind`blindEDM]
]


(* ::Input::Initialization:: *)
rawEDMErr[dblock_,gated_]:=If[gated,
edmFactor[dblock]getGatedError["EDMDB","asymmetry",dblock],
edmFactor[dblock] getTOFChannelErrors["EDMDB","asymmetry",dblock]
]


(* ::Input::Initialization:: *)
correctedEDM[dblock_,gated_]:=If[gated,
edmFactor[dblock] getGatedChannel["EDMCORRDB","asymmetry",dblock]+edmSign[dblock]SEDM3`Blind`blindEDM,
Transpose[getTOFChannelTimes["EDMCORRDB","asymmetry",dblock],(edmFactor[dblock] getTOFChannelData["EDMCORRDB","asymmetry",dblock])+edmSign[dblock]SEDM3`Blind`blindEDM]
]


(* ::Input::Initialization:: *)
correctedEDMErr[dblock_,gated_]:=If[gated,
edmFactor[dblock] getGatedError["EDMCORRDB","asymmetry",dblock],
edmFactor[dblock] getTOFChannelErrors["EDMCORRDB","asymmetry",dblock]
]


(* ::Input::Initialization:: *)
counts[dblock_,detector_,gated_]:=If[gated,
(getGatedChannel[{"SIG"},detector,dblock] dblock@Config@Settings["numberOfPoints"])/dblock@DetectorCalibrations[detector],
(getTOFChannelData[{"SIG"},detector,dblock] dblock@Config@Settings["numberOfPoints"])/dblock@DetectorCalibrations[detector]
]


(* ::Input::Initialization:: *)
contrast[dblock_,gated_]:= Module[{dbStep,magCal,interferometerLength,phaseStep},

dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];
interferometerLength=Check[dblock@Config@Settings["rf2CentreTime"]-dblock@Config@Settings["rf1CentreTime"],800]*10^-6;
phaseStep=(bohrMagneton*dbStep*magCal*10^-9*interferometerLength)/hbar;

getChannel[dblock,"asymmetry",gated]/phaseStep;
]


(* ::Input::Initialization:: *)
sn[counts_]:=Abs[1/Sqrt[counts]];


(* ::Input::Initialization:: *)
extractPhysicalQuantities[dblock_,gated_]:=
{"rawEDM"->rawEDM[dblock,gated],
"rawEDMErr"->rawEDMErr[dblock,gated],
"signedEDM"->edmSign[dblock] rawEDM[dblock,gated],
"correctedEDM"->correctedEDM[dblock,gated],
"correctedEDMErr"->correctedEDMErr[dblock,gated],
"signedCorrectedEDM"->edmSign[dblock] correctedEDM[dblock,gated],
"pmtCountsTop"->counts[dblock,"topProbeNoBackground",gated],
"pmtCountsBottom"->counts[dblock,"bottomProbeScaled",gated],
"pmtLaserBackgroundTop"->counts[dblock,"TopDetectorBackground",gated],
"pmtLaserBackgroundBottom"->counts[dblock,"BottomDetectorBackground",gated],
"contrast"->contrast[dblock,gated],
"polarisation"->polarisationFactor[Abs[cField[dblock]]/1000]}


(* ::Input::Initialization:: *)
(*extractNoiseData[dblock_]:=Module[{normShotNoiseV\[Mu]sPerShot,normCal,topCal,highFrequencyNormOverShotNoise,normFourier,normShotNoisePPMPerChannel,topShotNoiseV\[Mu]sPerShot,topShotNoisePPMPerChannel},

normCal=1/(If[#==0.08928571428571429`,1/(1.9 8.5),#]&[dblock@DetectorCalibrations["norm"]]);
topCal=1/(If[#==0.14492753623188406`,1.97/6.28,#]&[dblock@DetectorCalibrations["top"]]);

normFourier=Take[#,Round[Length[#]/2]]&[dblock@NormFourier@FFT];

normShotNoiseV\[Mu]sPerShot=\[Sqrt](1/normCal(getChannel[{"SIG"},"norm",dblock]+(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@Background)*(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateHigh-dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateLow)));
highFrequencyNormOverShotNoise=Mean[Drop[normFourier,Round[Length[normFourier]/4]]]/normShotNoiseV\[Mu]sPerShot;
normShotNoisePPMPerChannel=10^6normShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"norm",dblock]\[Sqrt]dblock@Config@Settings["numberOfPoints"]);
topShotNoiseV\[Mu]sPerShot=Sqrt[ getChannel[{"SIG"},"top",dblock]/topCal];
topShotNoisePPMPerChannel=10^6topShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"top",dblock]\[Sqrt]dblock@Config@Settings["numberOfPoints"]);

{"normFourier"\[Rule]normFourier,
"normShotNoiseV\[Mu]sPerShot"\[Rule]normShotNoiseV\[Mu]sPerShot,
"hfNormOverShotNoise"\[Rule]highFrequencyNormOverShotNoise,
"normShotNoisePPMPerChannel"\[Rule]normShotNoisePPMPerChannel,
"topShotNoisePPMPerChannel"\[Rule]topShotNoisePPMPerChannel
}
]*)


(* ::Input::Initialization:: *)
(*getChannelNoisePPM[dblock_,switches_,detector_]:=10^6getError[switches,detector,dblock]/getChannel[{"SIG"},detector,dblock]*)


(* ::Input::Initialization:: *)
analyseBlock[dblock_,gated_]:=Module[{physicalQuantities},
physicalQuantities=extractPhysicalQuantities[dblock,gated];
(*noiseDat=extractNoiseData[dblock];*)
{"analysisResults"->physicalQuantities}
];


(* ::Input::Initialization:: *)
extractSummaryData[dbl_,abl_,gated_]:={
"EMag"->getChannel[{"E"},"magnetometer",dbl,gated],
"SIGMag"->getChannel[{"SIG"},"magnetometer",dbl,gated],
"BMag"->getChannel[{"B"},"magnetometer",dbl,gated],
"EMagErr"->getError[{"E"},"magnetometer",dbl,gated],
"SIGMagErr"->getError[{"SIG"},"magnetometer",dbl,gated],
"BMagErr"->getError[{"B"},"magnetometer",dbl,gated],
"BDBMag"->getChannel[{"B","DB"},"magnetometer",dbl,gated],
"BDBMagErr"->getError[{"B","DB"},"magnetometer",dbl,gated],

"PhaseLockFrequency"->getChannel[{"SIG"},"PhaseLockFrequency",dbl,gated],

"ENorthCurrent"->getChannel[{"E"},"NorthCurrent",dbl,gated],
"ESouthCurrent"->getChannel[{"E"},"SouthCurrent",dbl,gated],
"ENorthCurrentErr"->getError[{"E"},"NorthCurrent",dbl,gated],
"ESouthCurrentErr"->getError[{"E"},"SouthCurrent",dbl,gated],

"cSIGtop"->getChannel[{"SIG"},"topProbeNoBackground",dbl,gated],
"cSIGtopErr"->getError[{"SIG"},"topProbeBoBackground",dbl,gated],
"cSIGbottom"->getChannel[{"SIG"},"bottomProbeScaled",dbl,gated],
"cSIGbottomErr"->getError[{"SIG"},"bottomProbeScaled",dbl,gated],
"cLaserBackgroundtop"->getChannel[{"SIG"},"TopDetectorBackground",dbl,gated],
"cLaserBackgroundtopErr"->getError[{"SIG"},"TopDetectorBackground",dbl,gated],
"cLaserBackgroundbottom"->getChannel[{"SIG"},"BottomDetectorBackground",dbl,gated],
"cLaserBackgroundbottomErr"->getError[{"SIG"},"BottomDetectorBackground",dbl,gated],

"cRF1F"->(getChannel[{"RF1F"},"asymmetry",dbl,gated]),
"cRF2F"->(getChannel[{"RF2F"},"asymmetry",dbl,gated]),
"cRF1A"->(getChannel[{"RF1A"},"asymmetry",dbl,gated]),
"cRF2A"->(getChannel[{"RF2A"},"asymmetry",dbl,gated]),
"cRF1FErr"->(getError[{"RF1F"},"asymmetry",dbl,gated]),
"cRF2FErr"->(getError[{"RF2F"},"asymmetry",dbl,gated]),
"cRF1AErr"->(getError[{"RF1A"},"asymmetry",dbl,gated]),
"cRF2AErr"->(getError[{"RF2A"},"asymmetry",dbl,gated]),

"cRF1FDB"->(getChannel[{"RF1F","DB"},"asymmetry",dbl,gated]),
"cRF2FDB"->(getChannel[{"RF2F","DB"},"asymmetry",dbl,gated]),
"cRF1FE"->(getChannel[{"RF1F","E"},"asymmetry",dbl,gated]),
"cRF2FE"->(getChannel[{"RF2F","E"},"asymmetry",dbl,gated]),
"cRF1AE"->(getChannel[{"RF1A","E"},"asymmetry",dbl,gated]),
"cRF2AE"->(getChannel[{"RF2A","E"},"asymmetry",dbl,gated]),
"cRF1AB"->(getChannel[{"RF1A","B"},"asymmetry",dbl,gated]),
"cRF2AB"->(getChannel[{"RF2A","B"},"asymmetry",dbl,gated]),
"cRF1FEDB"->(getChannel[{"RF1F","E","DB"},"asymmetry",dbl,gated]),
"cRF2FEDB"->(getChannel[{"RF2F","E","DB"},"asymmetry",dbl,gated]),
"cRF1FDBErr"->(getError[{"RF1F","DB"},"asymmetry",dbl,gated]),
"cRF2FDBErr"->(getError[{"RF2F","DB"},"asymmetry",dbl,gated]),
"cRF1FEErr"->(getError[{"RF1F","E"},"asymmetry",dbl,gated]),
"cRF2FEErr"->(getError[{"RF2F","E"},"asymmetry",dbl,gated]),
"cRF1AEErr"->(getError[{"RF1A","E"},"asymmetry",dbl,gated]),
"cRF2AEErr"->(getError[{"RF2A","E"},"asymmetry",dbl,gated]),
"cRF1ABErr"->(getError[{"RF1A","B"},"asymmetry",dbl,gated]),
"cRF2ABErr"->(getError[{"RF2A","B"},"asymmetry",dbl,gated]),
"cRF1FEDBErr"->(getError[{"RF1F","E","DB"},"asymmetry",dbl,gated]),
"cRF2FEDBErr"->(getError[{"RF2F","E","DB"},"asymmetry",dbl,gated]),

"cEB"->getChannel[{"B","E"},"asymmetry",dbl,gated],
"cEBErr"->getError[{"B","E"},"asymmetry",dbl,gated],
"cEBDB"->getChannel[{"B","E","DB"},"asymmetry",dbl,gated],
"cEBDBErr"->getError[{"B","E","DB"},"asymmetry",dbl,gated],
"cDB"->getChannel[{"DB"},"asymmetry",dbl,gated],
"cDBErr"->getError[{"DB"},"asymmetry",dbl,gated],
"cB"->getChannel[{"B"},"asymmetry",dbl,gated],
"cBErr"->getError[{"B"},"asymmetry",dbl,gated],
"cEDB"->getChannel[{"E","DB"},"asymmetry",dbl,gated],
"cEDBErr"->getError[{"E","DB"},"asymmetry",dbl,gated],
"cBDB"->getChannel[{"B","DB"},"asymmetry",dbl,gated],
"cBDBErr"->getError[{"B","DB"},"asymmetry",dbl,gated],

"signedEDM"->("signedEDM"/.("analysisResults"/.abl)),
"rawEDMErr"->("rawEDMErr"/.("analysisResults"/.abl)),
"signedCorrectedEDM"->("signedCorrectedEDM"/.("analysisResults"/.abl)),
"correctedEDMErr"->("correctedEDMErr"/.("analysisResults"/.abl)),
"edmFactor"->edmFactor[dbl],

"Pi"->getChannel[{"PI"},"asymmetry",dbl,gated],
"LF1"->getChannel[{"LF1"},"asymmetry",dbl,gated],
"LF1Err"->getError[{"LF1"},"asymmetry",dbl,gated],
"LF1B"->getChannel[{"LF1","B"},"asymmetry",dbl,gated],
"LF1BErr"->getError[{"LF1","B"},"asymmetry",dbl,gated],

"phaseScramblerV"->dbl@Config@Settings["phaseScramblerV"],
"bState"->dbl@Config@Settings["bState"],
"cluster"->dbl@Config@Settings["cluster"],
"clusterIndex"->dbl@Config@Settings["clusterIndex"],
"eState"->dbl@Config@Settings["eState"],
"rfState"->dbl@Config@Settings["rfState"],
"mwState"->dbl@Config@Settings["mwState"],
"ePlus"->dbl@Config@Settings["ePlus"],
"eMinus"->dbl@Config@Settings["eMinus"],
"timeStamp"->dbl@TimeStamp@Ticks,
"hour"->dbl@TimeStamp@Hour,

"rf1Step"->dbl@Config@GetModulationByName["RF1F"]@PhysicalStep,
"rf2Step"->dbl@Config@GetModulationByName["RF2F"]@PhysicalStep,
"rf1fCentre"->dbl@Config@GetModulationByName["RF1F"]@PhysicalCentre,
"rf2fCentre"->dbl@Config@GetModulationByName["RF2F"]@PhysicalCentre,
"rf1Power"->dbl@Config@GetModulationByName["RF1A"]@PhysicalCentre,
"rf2Power"->dbl@Config@GetModulationByName["RF2A"]@PhysicalCentre,
"BiasC"->dbl@Config@Settings["bBiasV"],
"BStep"->dbl@Config@GetModulationByName["B"]@PhysicalStep,
(*"LF1PhysicalCentre"\[Rule]If[#\[Equal]0,1547,#]&[(dbl@Config@GetModulationByName["LF1"]@PhysicalCentre)],*)

"BDB"->dbl@getChannel["BDB","asymmetry",gated],
"BDBErr"->dbl@getError["BDB","asymmetry",gated],
"RF1FDB"->dbl@getChannel["RF1FDB","asymmetry",gated],
"RF1FDBErr"->dbl@getError["RF1FDB","asymmetry",gated],
"RF2FDB"->dbl@getChannel["RF2FDB","asymmetry",gated],
"RF2FDBErr"->dbl@getError["RF2FDB","asymmetry",gated],
"RF1FDBDB"->dbl@getChannel["RF1FDBDB","asymmetry",gated],
"RF1FDBDBErr"->dbl@getError["RF1FDBDB","asymmetry",gated],
"RF2FDBDB"->dbl@getChannel["RF2FDBDB","asymmetry",gated],
"RF2FDBDBErr"->dbl@getError["RF2FDBDB","asymmetry",gated],
"ERF1FDB"->dbl@getChannel["ERF1FDB","asymmetry",gated],
"ERF1FDBErr"->dbl@getError["ERF1FDB","asymmetry",gated],
"ERF2FDB"->dbl@getChannel["ERF2FDB","asymmetry",gated],
"ERF2FDBErr"->dbl@getChannel["ERF2FDB","asymmetry",gated],
"ERF1FDBDB"->dbl@getChannel["ERF1FDBDB","asymmetry",gated],
"ERF1FDBDBErr"->dbl@getChannel["ERF1FDBDB","asymmetry",gated],
"ERF2FDBDB"->dbl@getChannel["ERF2FDBDB","asymmetry",gated],
"ERF2FDBDBErr"->dbl@getError["ERF2FDBDB","asymmetry",gated],
"BRF1FCORRDB"->dbl@getChannel["BRF1FCORRDB","asymmetry",gated],
"BRF1FCORRDBErr"->dbl@getError["BRF1FCORRDB","asymmetry",gated],
"BRF2FCORRDB"->dbl@getChannel["BRF2FCORRDB","asymmetry",gated],
"BRF2FCORRDBErr"->dbl@getError["BRF2FCORRDB","asymmetry",gated]
}


(* ::Input::Initialization:: *)
correctBlock[summaryData_,wiggleSlope_,wiggleSlopeDB_,bCorrectionSlope_,rf1PhaseSlope_,rf2PhaseSlope_,offsetCorrection_]:=Module[{wiggleCorr,wiggleCorrDB,bCorr,rf1PhaseCorr,rf2PhaseCorr,fullyCorrectedBlockEDM},

wiggleCorr=wiggleSlope ("RF1FDBNL"/.summaryData)[[1]];
wiggleCorrDB=wiggleSlopeDB ("RF1FDBDBNL"/.summaryData)[[1]];
bCorr=bCorrectionSlope("E"/.#)boolSign["eState"/.#]&[summaryData];
rf1PhaseCorr=rf1PhaseSlope("edmFactor"/.#)(1/("rf1Step"/.#))First[(boolSign["bState"/.#]("BRF1FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF1FDBNL"/.#))]&[summaryData];
rf2PhaseCorr=rf2PhaseSlope("edmFactor"/.#)(1/("rf2Step"/.#))First[(boolSign["bState"/.#]("BRF2FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF2FDBNL"/.#))]&[summaryData];

fullyCorrectedBlockEDM=("signedCorrectedEDMNLNormed"/.summaryData)-(wiggleCorr+wiggleCorrDB)/2-bCorr-rf1PhaseCorr-rf2PhaseCorr-offsetCorrection;

Join[summaryData,{"wiggleCorr"->wiggleCorr,"wiggleCorrDB"->wiggleCorrDB,"bCorr"->bCorr,"rf1PhaseCorr"->rf1PhaseCorr,"rf2PhaseCorr"->rf2PhaseCorr,"offsetCorrection"->offsetCorrection,"fullyCorrectedBlockEDM"->fullyCorrectedBlockEDM}]
]


(* ::Input::Initialization:: *)
generatePulsedRFGates[rf1Centre_,rf2Centre_,rf1KeepLength_,rf2KeepLength_,offset_]:=Module[{rf1Gates,rf2Gates},
rf1Gates=tCut[rf1Centre,kMachineLength/kRF1Ratio,kMachineLength,#]&/@({-1,1}rf1KeepLength);
rf2Gates=tCut[rf2Centre,kMachineLength/kRF2Ratio,kMachineLength,#]&/@({-1,1}rf2KeepLength);
Round[{Max[#[[1]]]-offset,Min[#[[2]]]-offset}&[Transpose[{rf1Gates,rf2Gates}]]]
]

generatePulsedRFGates[block_,rf1KeepLength_,rf2KeepLength_,offset_]:=
Module[{config},
config=extractConfig[block];
generatePulsedRFGates["rf1CentreTime"/.config,"rf2CentreTime"/.config,rf1KeepLength,rf2KeepLength,offset]
]


(* ::Input::Initialization:: *)
tCut[tpulse_,rfLength_,beamLength_,keepLength_]:=1/(rfLength/beamLength-keepLength/beamLength) tpulse;


(* ::Input::Initialization:: *)
getPulseTiming[block_,detector_]:=Module[{model,tofData,centreGuess,widthGuess,fit},
tofData=Transpose[{block[GetAverageTOF[detector][Times]],block[GetAverageTOF[detector][Data]]}];
model=a E^(-(1/2) ((x-b)/ c)^2);
centreGuess=Mean[First/@tofData];
widthGuess=First[Last[tofData]-First[tofData]]/50;
fit=Check[
FindFit[tofData,model,{a,{b,centreGuess},{c,widthGuess},d},x],
(* Do something roughly sensible if the fit doesn't converge *)
{b->centreGuess,c->1/2 (First[Last[tofData]]-First[First[tofData]])}
];
{"centre"->b,"fwhm"->2Sqrt[2Log[2]]Abs[c]}/.fit
]


(* ::Input::Initialization:: *)
getGateTiming[block_,detector_,w_]:=Round[{"centre"-w ("fwhm")/2,"centre"+w ("fwhm")/2}]/.getPulseTiming[block,detector]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
