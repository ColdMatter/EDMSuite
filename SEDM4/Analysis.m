(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM4`Analysis`","SEDM4`EDMSuite`","SEDM4`Polarisation`","SEDM4`Database`","SEDM4`Blind`","SEDM4`Statistics`","NETLink`","JLink`"];


(* ::Input::Initialization:: *)
weightedMean::usage="Takes  a list of {value, error} pairs and calculates the weighted mean.";
integrateTOF::usage="Takes a block and integrates to TOF profiles for the specified detector. The Boolean parameter returnIntegral determines whether the returned values are the integrals (in V \[Mu]s) or the average values (in V).";
getAverageBG::usage="";
getPulseTiming::usage="";
getGateTiming::usage="";
integrateTOFBackSubtract::usage="";
extractNoiseData::usage="";
getChannelNoisePPM::usage="";
analyseBlock::usage="This function take a block and an extraction function and analyses the block.The extraction function is applied to the block and is expected to return a list of detectorDatas.The detector data is format is defined by integrateTOF.This is the usual way to generate detector data,but other ways can be plugged in if you like-for instance extracting data from the single point values instead of the TOFs.";
generatePulsedRFGates::usage="Calculates the correct gates to exclude molecules more than a given distance from the guard plate centres. The centres are in microseconds, the keep lengths in m. Molecules are selected symmetrically around the centre position. The offset parameter is to deal with a bug in the acquisition software before September 2005. If in doubt, it should be set to zero.";

basis::usage="";
edmWaveform::usage="";
boolSign::usage="";
extractPhysicalQuantities::usage="";

cField::usage="";
edmFactor::usage="";
rawEDM::usage="";
edmSign::usage="";
rawEDMErr::usage="";
gamma::usage="";
geometricCorrection::usage="";
geometricCorrectionErr::usage="";
correctedEDM::usage="";
correctedEDMErr::usage="";
counts::usage="";
sn::usage="";
correctedEDMNLNormed::usage="";
correctedEDMErrNLNormed::usage="";

extractSummaryData::usage="";
correctBlock::usage="";


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
electronCharge=1.6022*10^-19;
bohrMagneton=9.274*10^-24;
saturatedEffectiveField=26*10^9;
plateSpacing=1.2;
curveHalfWidthCurrent= 0.647  (*1260 us 0.49265*);(*long machine 0.5362*)(*Short Machine 0.665*) (*should be half the ideal DB step*);

kMachineLength=1.3;
kRF1Ratio=1.103*2.31;
kRF2Ratio=1.103;


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
basis[bit_, length_] := Flatten[Table[ { Table[ 1, {2^(bit-1)}], Table[-1, {2^(bit-1)}]} , {length/ (2^bit)}]];
edmWaveform[code_]:= Module[{numWave},numWave=\!\(
\*UnderoverscriptBox[\(\[Product]\), \(i\  = \ 1\), \(Length[code]\)]\ \(If[\ code[[i]], \ basis[Length[code] - \ i + 1, \ 
\*SuperscriptBox[\(2\), \(Length[code]\)]], \ Table[1, {
\*SuperscriptBox[\(2\), \(Length[code]\)]}]]\)\);
(#==1)&/@numWave
];

boolSign[bool_]:=If[bool,1,-1]


(* ::Input::Initialization:: *)
integrateTOF[block_,detector_Integer,gateStart_Integer,gateEnd_Integer,returnIntegral_,detectorName_String]:=Module[{gatedData,gatePeriod,dat,cal},

dat=If[returnIntegral,
gatedData=block@GetTOFIntegralArray[detector,gateStart,gateEnd],
gatedData=block@GetTOFMeanArray[detector,gateStart,gateEnd]
];

cal=block@Points[0]@Shot@TOFs[detector]@Calibration;

{"name"->detectorName,"data"->dat,"calibration"->cal}
];


(* ::Input::Initialization:: *)
getAverageBG[block_,detector_,gateStart_,gateEnd_]:=Mean["data"/.integrateTOF[block,detector,gateStart,gateEnd,False,""]]


(* ::Input::Initialization:: *)
integrateTOFBackSubtract[block_,detector_,gateStart_,gateEnd_,bgStart_,bgEnd_,name_]:=Module[{integral,bg,newData,subbedBG},
integral=integrateTOF[block,detector,gateStart,gateEnd,True,name];
bg=getAverageBG[block,detector,bgStart,bgEnd];
subbedBG=(bg*(gateEnd-gateStart));
newData=("data"/.integral)-subbedBG;
{"name"->name,"data"->newData,"calibration"->("calibration"/.integral),"subtractedBG"->subbedBG}
]


(* ::Input::Initialization:: *)
cField[dblock_]:=(dblock@Config@Settings["ePlus"] - dblock@Config@Settings["eMinus"])/plateSpacing;


(* ::Input::Initialization:: *)
edmFactor[dblock_]:= Module[{dbStep,magCal},

dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];

1/electronCharge (bohrMagneton * dbStep*magCal*10^-9)1/(saturatedEffectiveField polarisationFactor[Abs[cField[dblock]]/1000])
];


(* ::Input::Initialization:: *)
edmSign[dblock_]:= boolSign[dblock@Config@Settings["eState"]] boolSign[dblock@Config@Settings["bState"]];


(* ::Input::Initialization:: *)
rawEDMGated[dblock_,detector_]:=(edmFactor[dblock] getGatedChannel["EDMDB",detector,dblock])+edmSign[dblock]SEDM3`Blind`blindEDM


(* ::Input::Initialization:: *)
rawEDMGatedErr[dblock_,detector_]:=edmFactor[dblock]getGatedError["EDMDB",detector,dblock];


(* ::Input::Initialization:: *)
correctedEDMGated[dblock_]:=
edmFactor[dblock](dblock@["EDMCORRDB","topNormed"])[[1]]+edmSign[dblock]SEDM3`Blind`blindEDM;


(* ::Input::Initialization:: *)
correctedEDMErrNLNormed[dblock_]:=
edmFactor[dblock](dblock@GetSpecialChannelValueAndError["EDMCORRDB","topNormed"])[[2]];


(* ::Input::Initialization:: *)
correctedEDMNLNormedUSB[dblock_]:=
edmFactor[dblock](dblock@GetSpecialChannelValueAndError["EDMCORRDB","topNormed"])[[1]]+SEDM3`Blind`blindEDM;


(* ::Input::Initialization:: *)
counts[dblock_,detector_]:=(getChannel[{"SIG"},detector,dblock] dblock@Config@Settings["numberOfPoints"])/dblock@DetectorCalibrations[detector];


(* ::Input::Initialization:: *)
sn[counts_]:=Abs[1/Sqrt[counts]];


(* ::Input::Initialization:: *)
extractPhysicalQuantities[dblock_]:={"polarisation"->polarisationFactor[Abs[cField[dblock]]/1000],
"rawEDM"->rawEDM[dblock,"top"],
"signedEDM"->edmSign[dblock]rawEDM[dblock,"top"],
"rawEDMErr"->rawEDMErr[dblock,"top"],
"geometricCorrection"->geometricCorrection[dblock,"top"],
"geometricCorrectionError"->geometricCorrectionErr[dblock,"top"],
"correctedEDM"->correctedEDM[dblock,"top"],
"signedCorrectedEDM"->edmSign[dblock]correctedEDM[dblock,"top"],
"correctedEDMErr"->correctedEDMErr[dblock,"top"],
"rawEDMNormed"->rawEDM[dblock,"topNormed"],
"signedEDMNormed"->edmSign[dblock]rawEDM[dblock,"topNormed"],
"rawEDMErrNormed"->rawEDMErr[dblock,"topNormed"],
"geometricCorrectionNormed"->geometricCorrection[dblock,"topNormed"],
"geometricCorrectionErrorNormed"->geometricCorrectionErr[dblock,"topNormed"],
"correctedEDMNormed"->correctedEDM[dblock,"topNormed"],
"signedCorrectedEDMNormed"->edmSign[dblock]correctedEDM[dblock,"topNormed"],
"correctedEDMErrNormed"->correctedEDMErr[dblock,"topNormed"],
"signedCorrectedEDMNLNormed"->edmSign[dblock]correctedEDMNLNormed[dblock],
"correctedEDMErrNLNormed"->correctedEDMErrNLNormed[dblock],
"pmtCounts"->counts[dblock,"top"]
}


(* ::Input::Initialization:: *)
extractNoiseData[dblock_]:=Module[{normShotNoiseV\[Mu]sPerShot,normCal,topCal,highFrequencyNormOverShotNoise,normFourier,normShotNoisePPMPerChannel,topShotNoiseV\[Mu]sPerShot,topShotNoisePPMPerChannel},

normCal=1/(If[#==0.08928571428571429`,1/(1.9 8.5),#]&[dblock@DetectorCalibrations["norm"]]);
topCal=1/(If[#==0.14492753623188406`,1.97/6.28,#]&[dblock@DetectorCalibrations["top"]]);

normFourier=Take[#,Round[Length[#]/2]]&[dblock@NormFourier@FFT];

normShotNoiseV\[Mu]sPerShot=\[Sqrt](1/normCal (getChannel[{"SIG"},"norm",dblock]+(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@Background)*(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateHigh-dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateLow)));
highFrequencyNormOverShotNoise=Mean[Drop[normFourier,Round[Length[normFourier]/4]]]/normShotNoiseV\[Mu]sPerShot;
normShotNoisePPMPerChannel=10^6 normShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"norm",dblock]\[Sqrt]dblock@Config@Settings["numberOfPoints"]);
topShotNoiseV\[Mu]sPerShot=Sqrt[ getChannel[{"SIG"},"top",dblock]/topCal];
topShotNoisePPMPerChannel=10^6 topShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"top",dblock]\[Sqrt]dblock@Config@Settings["numberOfPoints"]);

{"normFourier"->normFourier,
"normShotNoiseV\[Mu]sPerShot"->normShotNoiseV\[Mu]sPerShot,
"hfNormOverShotNoise"->highFrequencyNormOverShotNoise,
"normShotNoisePPMPerChannel"->normShotNoisePPMPerChannel,
"topShotNoisePPMPerChannel"->topShotNoisePPMPerChannel
}
]


(* ::Input::Initialization:: *)
getChannelNoisePPM[dblock_,switches_,detector_]:=10^6 getError[switches,detector,dblock]/getChannel[{"SIG"},detector,dblock]


(* ::Input::Initialization:: *)
analyseBlock[dblock_]:=Module[{physicalQuantities,noiseDat},
physicalQuantities=extractPhysicalQuantities[dblock];
noiseDat=extractNoiseData[dblock];
{"analysisResults"->physicalQuantities,"noiseData"->noiseDat}
];


(* ::Input::Initialization:: *)
(*extractSummaryData[dbl_,abl_]:={
"E"\[Rule](getChannel[{"E"},"mag1",dbl]),
"B"\[Rule](getChannel[{"SIG"},"mag1",dbl]),
"EErr"\[Rule](getError[{"E"},"mag1",dbl]),
"B\[Alpha]E"\[Rule](getChannel[{"B","E"},"topNormed",dbl]),
"DB"\[Rule](getChannel[{"DB"},"topNormed",dbl]),
"RF1F"\[Rule](getChannelAndError[{"RF1F"},"topNormed",dbl]),
"RF2F"\[Rule](getChannelAndError[{"RF2F"},"topNormed",dbl]),
"RF1FDB"\[Rule](getChannelAndError[{"RF1F","DB"},"topNormed",dbl]),
"RF2FDB"\[Rule](getChannelAndError[{"RF2F","DB"},"topNormed",dbl]),
"RF1FE"\[Rule](getChannelAndError[{"RF1F","E"},"topNormed",dbl]),
"RF2FE"\[Rule](getChannelAndError[{"RF2F","E"},"topNormed",dbl]),
"RF1FEDB"\[Rule](getChannelAndError[{"RF1F","E","DB"},"topNormed",dbl]),
"RF2FEDB"\[Rule](getChannelAndError[{"RF2F","E","DB"},"topNormed",dbl]),
"Bmol"\[Rule](getChannel[{"B"},"topNormed",dbl]),
"rfCurrent"\[Rule] (dbl@GetChannelValueAndError[{"SIG"},"rfCurrent"]),
"rfCurrentE"\[Rule] (dbl@GetChannelValueAndError[{"E"},"rfCurrent"]),
"E\[Alpha]DB"\[Rule](getChannel[{"E","DB"},"topNormed",dbl]),
"signedCorrectedEDMNLNormed"\[Rule]("signedCorrectedEDMNLNormed"/.("analysisResults"/.abl)),
"correctedEDMErrNLNormed"\[Rule]("correctedEDMErrNLNormed"/.("analysisResults"/.abl)),
"edmFactor"\[Rule]edmFactor[dbl],
"bState"\[Rule](dbl@Config@Settings["bState"]),
"cluster"\[Rule](dbl@Config@Settings["cluster"]),
"clusterIndex"\[Rule](dbl@Config@Settings["clusterIndex"]),
"eState"\[Rule](dbl@Config@Settings["eState"]),
"rfState"\[Rule](dbl@Config@Settings["rfState"]),
"ePlus"\[Rule](dbl@Config@Settings["ePlus"]),
"eMinus"\[Rule](dbl@Config@Settings["eMinus"]),
"probePolarizerAngle"\[Rule](dbl@Config@Settings["probePolarizerAngle"]),
"pumpPolarizerAngle"\[Rule](dbl@Config@Settings["pumpPolarizerAngle"]),
"timeStamp"\[Rule](dbl@TimeStamp@Ticks),
"hour"\[Rule](dbl@TimeStamp@Hour),
"rf1Step"\[Rule]If[#\[Equal]0,1547,#]&[(dbl@Config@GetModulationByName["RF1F"]@PhysicalStep)],
"rf2Step"\[Rule]If[#\[Equal]0,1630,#]&[(dbl@Config@GetModulationByName["RF2F"]@PhysicalStep)],
"CORRDB"\[Rule](dbl@ChannelValues[6]@SpecialValues["CORRDB"]),
"RF1FDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["RF1FDB"]),
"RF2FDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["RF2FDB"]),
"RF1FDBDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["RF1FDBDB"]),
"RF2FDBDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["RF2FDBDB"]),
"ERF1FDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["ERF1FDB"]),
"ERF2FDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["ERF2FDB"]),
"ERF1FDBDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["ERF1FDBDB"]),
"ERF2FDBDBNL"\[Rule](dbl@ChannelValues[6]@SpecialValues["ERF2FDBDB"]),
"BRF1FCORRDB"\[Rule](dbl@ChannelValues[6]@SpecialValues["BRF1FCORRDB"]),
"BRF2FCORRDB"\[Rule](dbl@ChannelValues[6]@SpecialValues["BRF2FCORRDB"])
}*) 


(* ::Input::Initialization:: *)
extractSummaryData[dbl_,abl_]:={
"E"->Check[(getChannel[{"E"},"magnetometer",dbl]),(getChannel[{"E"},"mag1",dbl])],
"B"->Check[(getChannel[{"SIG"},"magnetometer",dbl]),(getChannel[{"SIG"},"mag1",dbl])],
"BMag"->Check[(getChannel[{"B"},"magnetometer",dbl]),(getChannel[{"B"},"mag1",dbl])],
"BErr"->Check[(getError[{"SIG"},"magnetometer",dbl]),(getError[{"SIG"},"mag1",dbl])],
"BMagErr"->Check[(getError[{"B"},"magnetometer",dbl]),(getError[{"B"},"mag1",dbl])],
"BDBMag"->Check[(getChannel[{"B","DB"},"magnetometer",dbl]),(getChannel[{"B","DB"},"mag1",dbl])],
"BDBMagErr"->Check[(getError[{"B","DB"},"magnetometer",dbl]),(getError[{"B","DB"},"mag1",dbl])],
"LF1Mini1"->getChannel[{"LF1"},"MiniFlux1",dbl],
"LF1Mini2"->getChannel[{"LF1"},"MiniFlux2",dbl],
"LF1Mini3"->getChannel[{"LF1"},"MiniFlux3",dbl],
"Mini1"->getChannel[{"SIG"},"MiniFlux1",dbl],
"Mini2"->getChannel[{"SIG"},"MiniFlux2",dbl],
"Mini3"->getChannel[{"SIG"},"MiniFlux3",dbl],
"EMini1"->getChannel[{"E"},"MiniFlux1",dbl],
"EMini2"->getChannel[{"E"},"MiniFlux2",dbl],
"EMini3"->getChannel[{"E"},"MiniFlux3",dbl],
"cPlusV"->getChannel[{"SIG"},"reflectedrf1Amplitude",dbl],
"cMinusV"->getChannel[{"SIG"},"reflectedrf2Amplitude",dbl],
"EcPlusV"->getChannel[{"E"},"reflectedrf1Amplitude",dbl],
"EcMinusV"->getChannel[{"E"},"reflectedrf2Amplitude",dbl],
"EBcPlusV"->getChannel[{"B","E"},"reflectedrf1Amplitude",dbl],
"EBcMinusV"->getChannel[{"B","E"},"reflectedrf2Amplitude",dbl],
"PhaseLockFrequency"->getChannel[{"SIG"},"PhaseLockFrequency",dbl],
"ncE"->getChannel[{"E"},"NorthCurrent",dbl],
"scE"->getChannel[{"E"},"SouthCurrent",dbl],
"ncEErr"->getError[{"E"},"NorthCurrent",dbl],
"scEErr"->getError[{"E"},"SouthCurrent",dbl],
"rf1r"->getChannel[{"SIG"},"reflectedrf1Amplitude",dbl],
"rf2r"->getChannel[{"SIG"},"reflectedrf2Amplitude",dbl],
"rf1rE"->getChannel[{"E"},"reflectedrf1Amplitude",dbl],
"rf2rE"->getChannel[{"E"},"reflectedrf2Amplitude",dbl],
"rf1rEErr"->getError[{"E"},"reflectedrf1Amplitude",dbl],
"rf2rEErr"->getError[{"E"},"reflectedrf2Amplitude",dbl],
"EErr"->Check[(getError[{"E"},"magnetometer",dbl]),(getError[{"E"},"mag1",dbl])],
"B\[Alpha]E"->(getChannel[{"B","E"},"topNormed",dbl]),
"B\[Alpha]Etop"->(getChannel[{"B","E"},"top",dbl]),
"B\[Alpha]E\[Alpha]DB"->(getChannel[{"B","E","DB"},"topNormed",dbl]),
"B\[Alpha]E\[Alpha]DBtop"->(getChannel[{"B","E","DB"},"top",dbl]),
"DB"->(getChannel[{"DB"},"topNormed",dbl]),
"DBErr"->(getError[{"DB"},"topNormed",dbl]),
"DBtop"->(getChannel[{"DB"},"top",dbl]),
"DBtopErr"->(getError[{"DB"},"top",dbl]),
"SIG"->(getChannel[{"SIG"},"top",dbl]),
"SIGErr"->(getError[{"SIG"},"top",dbl]),
"Norm"->(getChannel[{"SIG"},"norm",dbl]),
"NormErr"->(getError[{"SIG"},"norm",dbl]),
"SIGNormed"->(getChannel[{"SIG"},"topNormed",dbl]),
"SIGNormedErr"->(getError[{"SIG"},"topNormed",dbl]),
"RF1F"->(getChannelAndError[{"RF1F"},"topNormed",dbl]),
"RF2F"->(getChannelAndError[{"RF2F"},"topNormed",dbl]),
"RF1A"->(getChannelAndError[{"RF1A"},"topNormed",dbl]),
"RF2A"->(getChannelAndError[{"RF2A"},"topNormed",dbl]),
"RF1FDB"->(getChannelAndError[{"RF1F","DB"},"topNormed",dbl]),
"RF2FDB"->(getChannelAndError[{"RF2F","DB"},"topNormed",dbl]),
"RF1FE"->(getChannelAndError[{"RF1F","E"},"topNormed",dbl]),
"RF2FE"->(getChannelAndError[{"RF2F","E"},"topNormed",dbl]),
"RF1AE"->(getChannelAndError[{"RF1A","E"},"topNormed",dbl]),
"RF2AE"->(getChannelAndError[{"RF2A","E"},"topNormed",dbl]),
"RF1AB"->(getChannelAndError[{"RF1A","B"},"topNormed",dbl]),
"RF2AB"->(getChannelAndError[{"RF2A","B"},"topNormed",dbl]),
"RF1FEDB"->(getChannelAndError[{"RF1F","E","DB"},"topNormed",dbl]),
"RF2FEDB"->(getChannelAndError[{"RF2F","E","DB"},"topNormed",dbl]),
"Bmol"->(getChannel[{"B"},"topNormed",dbl]),
"Bmoltop"->(getChannel[{"B"},"top",dbl]),
"BmolErr"->(getError[{"B"},"topNormed",dbl]),
"rfCurrent"-> Check[(dbl@GetChannelValueAndError[{"SIG"},"rfCurrent"]),0],
"rfCurrentE"->Check[(dbl@GetChannelValueAndError[{"E"},"rfCurrent"]),0],
"E\[Alpha]DB"->(getChannel[{"E","DB"},"topNormed",dbl]),
"E\[Alpha]DBtop"->(getChannel[{"E","DB"},"top",dbl]),
"B\[Alpha]DB"->(getError[{"B","DB"},"topNormed",dbl]),
"E\[Alpha]B"->(getChannel[{"E","B"},"topNormed",dbl]),
"E\[Alpha]B2"->(getChannel[{"B","E"},"topNormed",dbl]),
"signedEDM"->("signedEDM"/.("analysisResults"/.abl)),
"signedEDMNormed"->("signedEDMNormed"/.("analysisResults"/.abl)),
"rawEDMErrNormed"->("rawEDMErrNormed"/.("analysisResults"/.abl)),
"signedCorrectedEDM"->("signedCorrectedEDM"/.("analysisResults"/.abl)),
"geometricCorrection"->("geometricCorrection"/.("analysisResults"/.abl)),
"correctedEDMErr"->("correctedEDMErr"/.("analysisResults"/.abl)),
"signedCorrectedEDMNLNormed"->("signedCorrectedEDMNLNormed"/.("analysisResults"/.abl)),
"correctedEDMErrNLNormed"->("correctedEDMErrNLNormed"/.("analysisResults"/.abl)),
"edmFactor"->edmFactor[dbl],
"Pi"->(getChannel[{"PI"},"topNormed",dbl]),
"LF2"->(getChannel[{"LF2"},"topNormed",dbl]),
"LF1"->(getChannel[{"LF1"},"topNormed",dbl]),
"LF1Err"->(getError[{"LF1"},"topNormed",dbl]),
"LF1B"->(getChannel[{"LF1","B"},"topNormed",dbl]),
"LF1B"->(getChannel[{"LF1","E"},"topNormed",dbl]),
"LF1Btop"->(getChannel[{"LF1","B"},"top",dbl]),
"LF2Err"->(getError[{"LF2"},"topNormed",dbl]),
"LF2pump"->(getChannel[{"LF2"},"norm",dbl]),
"LF2pumpErr"->(getError[{"LF2"},"norm",dbl]),
"LF2top"->(getChannel[{"LF2"},"top",dbl]),
"LF2topErr"->(getError[{"LF2"},"top",dbl]),
"LF2DB"->(getChannelAndError[{"LF2","DB"},"topNormed",dbl]),
"LF2DBtop"->(getChannelAndError[{"LF2","DB"},"top",dbl]),
"phaseScramblerV"->(dbl@Config@Settings["phaseScramblerV"]),
"bState"->(dbl@Config@Settings["bState"]),
"cluster"->(dbl@Config@Settings["cluster"]),
"clusterIndex"->(dbl@Config@Settings["clusterIndex"]),
"eState"->(dbl@Config@Settings["eState"]),
"rfState"->(dbl@Config@Settings["rfState"]),
"ePlus"->(dbl@Config@Settings["ePlus"]),
"eMinus"->(dbl@Config@Settings["eMinus"]),
"probePolarizerAngle"->(dbl@Config@Settings["probePolarizerAngle"]),
"pumpPolarizerAngle"->(dbl@Config@Settings["pumpPolarizerAngle"]),
"pumpAOM"->(dbl@Config@Settings["pumpAOMFreq"]),
"timeStamp"->(dbl@TimeStamp@Ticks),
"hour"->(dbl@TimeStamp@Hour),
"rf1Step"->If[#==0,1547,#]&[(dbl@Config@GetModulationByName["RF1F"]@PhysicalStep)],
"rf2Step"->If[#==0,1630,#]&[(dbl@Config@GetModulationByName["RF2F"]@PhysicalStep)],
"rf1fCentre"->If[#==0,1547,#]&[(dbl@Config@GetModulationByName["RF1F"]@PhysicalCentre)],
"rf2fCentre"->If[#==0,1630,#]&[(dbl@Config@GetModulationByName["RF2F"]@PhysicalCentre)],
"rf1Power"->If[#==0,1547,#]&[(dbl@Config@GetModulationByName["RF1A"]@PhysicalCentre)],
"rf2Power"->If[#==0,1630,#]&[(dbl@Config@GetModulationByName["RF2A"]@PhysicalCentre)],
"BiasC"->(dbl@Config@Settings["bBiasV"]),
"bigB"->(dbl@Config@GetModulationByName["B"]@PhysicalStep),
"LF1PhysicalCentre"->If[#==0,1547,#]&[(dbl@Config@GetModulationByName["LF1"]@PhysicalCentre)],
"BDBNL"->dbl@GetSpecialChannelValueAndError["BDB","topNormed"],
"CORRDB"->dbl@GetSpecialChannelValueAndError["CORRDB","topNormed"],
"choCorrection"->dbl@GetSpecialChannelValueAndError["CORRDB_OLD","topNormed"],
"RF1FDBNL"->dbl@GetSpecialChannelValueAndError["RF1FDB","topNormed"],
"RF2FDBNL"->dbl@GetSpecialChannelValueAndError["RF2FDB","topNormed"],
"RF1FDBDBNL"->dbl@GetSpecialChannelValueAndError["RF1FDBDB","topNormed"],
"RF2FDBDBNL"->dbl@GetSpecialChannelValueAndError["RF2FDBDB","topNormed"],
"ERF1FDBNL"->dbl@GetSpecialChannelValueAndError["ERF1FDB","topNormed"],
"ERF2FDBNL"->dbl@GetSpecialChannelValueAndError["ERF2FDB","topNormed"],
"ERF1FDBDBNL"->dbl@GetSpecialChannelValueAndError["ERF1FDBDB","topNormed"],
"ERF2FDBDBNL"->dbl@GetSpecialChannelValueAndError["ERF2FDBDB","topNormed"],
"BRF1FCORRDB"->dbl@GetSpecialChannelValueAndError["BRF1FCORRDB","topNormed"],
"BRF2FCORRDB"->dbl@GetSpecialChannelValueAndError["BRF2FCORRDB","topNormed"],
"LF2DBDBNL"->dbl@GetSpecialChannelValueAndError["LF2DBDB","top"],
(*"LF2DBDBNL"\[Rule](dbl@ChannelValues[0]@SpecialValues["LF2DBDB"])*)
"0PlusBoost"->(dbl@Config@Settings["E0PlusBoost"])
}


(* ::Input::Initialization:: *)
correctBlock[summaryData_,wiggleSlope_,wiggleSlopeDB_,bCorrectionSlope_,rf1PhaseSlope_,rf2PhaseSlope_,offsetCorrection_]:=Module[{wiggleCorr,wiggleCorrDB,bCorr,rf1PhaseCorr,rf2PhaseCorr,fullyCorrectedBlockEDM},

wiggleCorr=wiggleSlope ("RF1FDBNL"/.summaryData)[[1]];
wiggleCorrDB=wiggleSlopeDB ("RF1FDBDBNL"/.summaryData)[[1]];
bCorr=bCorrectionSlope("E"/.#)boolSign["eState"/.#]&[summaryData];
rf1PhaseCorr=rf1PhaseSlope("edmFactor"/.#)(1/("rf1Step"/.#))First[(boolSign["bState"/.#]("BRF1FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF1FDBNL"/.#))]&[summaryData];
rf2PhaseCorr=rf2PhaseSlope("edmFactor"/.#)(1/("rf2Step"/.#))First[(boolSign["bState"/.#]("BRF2FCORRDB"/.#))]First[(boolSign["eState"/.#]("ERF2FDBNL"/.#))]&[summaryData];

fullyCorrectedBlockEDM=("signedCorrectedEDMNLNormed"/.summaryData)-(wiggleCorr+wiggleCorrDB)/2-bCorr-rf1PhaseCorr-rf2PhaseCorr-offsetCorrection;

Join[summaryData,{"wiggleCorr"->wiggleCorr,"wiggleCorrDB"->wiggleCorrDB,"bCorr"->bCorr,"rf1PhaseCorr"->rf1PhaseCorr,"rf2PhaseCorr"->rf2PhaseCorr,"offsetCorrection"->offsetCorrection,"fullyCorrectedBlockEDM"->fullyCorrectedBlockEDM}]
]


(* ::Input::Initialization:: *)
generatePulsedRFGates[rf1Centre_,rf2Centre_,rf1KeepLength_,rf2KeepLength_,offset_]:=Module[{rf1Gates,rf2Gates},
rf1Gates=tCut[rf1Centre,kMachineLength/kRF1Ratio,kMachineLength,#]&/@({-1,1}rf1KeepLength);
rf2Gates=tCut[rf2Centre,kMachineLength/kRF2Ratio,kMachineLength,#]&/@({-1,1}rf2KeepLength);
Round[{Max[#[[1]]]-offset,Min[#[[2]]]-offset}&[Transpose[{rf1Gates,rf2Gates}]]]
]

generatePulsedRFGates[block_,rf1KeepLength_,rf2KeepLength_,offset_]:=
Module[{config},
config=extractConfig[block];
generatePulsedRFGates["rf1CentreTime"/.config,"rf2CentreTime"/.config,rf1KeepLength,rf2KeepLength,offset]
]


(* ::Input::Initialization:: *)
tCut[tpulse_,rfLength_,beamLength_,keepLength_]:=1/(rfLength/beamLength-keepLength/beamLength) tpulse;


(* ::Input::Initialization:: *)
getPulseTiming[block_,detector_]:=Module[{model,tofData,centreGuess,widthGuess,fit},
tofData=Transpose[{block[GetAverageTOF[detector][Times]],block[GetAverageTOF[detector][Data]]}];
model=a E^(-(1/2) ((x-b)/ c)^2);
centreGuess=Mean[First/@tofData];
widthGuess=First[Last[tofData]-First[tofData]]/50;
fit=Check[
FindFit[tofData,model,{a,{b,centreGuess},{c,widthGuess},d},x],
(* Do something roughly sensible if the fit doesn't converge *)
{b->centreGuess,c->1/2 (First[Last[tofData]]-First[First[tofData]])}
];
{"centre"->b,"fwhm"->2Sqrt[2Log[2]]Abs[c]}/.fit
]


(* ::Input::Initialization:: *)
getGateTiming[block_,detector_,w_]:=Round[{"centre"-w ("fwhm")/2,"centre"+w ("fwhm")/2}]/.getPulseTiming[block,detector]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
