(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM4`Graphics`",{"SEDM4`Database`","SEDM4`Analysis`","SEDM4`TOF`"}];


(* ::Input::Initialization:: *)
plotTOFWithError::usage="plotTOFWithError[data_, plotTitle_] takes TOF data in the form {{\!\(\*SubscriptBox[\(time\), \(i\)]\), \!\(\*SubscriptBox[\(data\), \(i\)]\), \!\(\*SubscriptBox[\(error\), \(i\)]\)}...} and plots them with a title."
getGatedChannel::usage="";
getBlockDiagnostics::usage="";
plotClusterDiagnostics::usage=
"Plot a summary of a cluster for live diagnostic porpoises.";
colorFunc::usage="colorFunc shades numbers pleasingly";
(*plotShots::usage="Takes a block and some gate windows and plots all of the integrated shots, plus the average TOFs. It has its DisplayFunction set to the Identity.";
plotPulsedRFGates::usage="Plots the first few TOFs from a block plus the gates as calculated for the pulsed rf. You need to feed it the keep times and an offset (and a block!). It has its DisplayFunction set to the Identity.";*)
plotNormFourier::usage="";


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
plotTOFWithError[data_,plotTitle_]:=ListPlot[{#[[1]],Around[#[[2]],#[[3]]]}&/@data,PlotLabel->plotTitle]

getGatedChannel[dblock_,detector_,channel_,gateLow_,gateHigh_]:=Module[{tof,trimmedTof},
tof=getTOFChannel[channel,detector,dblock];
trimmedTof=Select[tof,gateLow<=#[[1]]<=gateHigh&];
channel<>"_"<>detector->meanOfTOFWithError[trimmedTof]
]

getNonTofChannel[dblock_,detector_,channel_]:=channel<>"_"<>detector->getPointChannel[channel,detector,dblock]

getBlockDiagnostics[uid_,detectorAndChannelList_,gateLow_,gateHigh_,pointDetectorAndChannelList_]:=
Module[{db,blockTime,blockPhysicalQts,gatedChannels,pointChannels,shotNoise,edmNoise},
NETBlock[
db=getDBlock[uid];
blockTime=db@TimeStamp@Ticks;

gatedChannels=getGatedChannel[db,#[[1]],#[[2]],gateLow,gateHigh]&/@detectorAndChannelList;
pointChannels=getNonTofChannel[db,#[[1]],#[[2]]]&/@pointDetectorAndChannelList;
blockPhysicalQts=(#[[1]]->weightedMeanOfTOFWithError[Select[#[[2]],gateLow<=#[[1]]<=gateHigh&]])&/@extractPhysicalQuantities[db];
shotNoise=(#[[1]]->Sqrt[Total[(Last/@Select[#[[2]],gateLow<=#[[1]]<=gateHigh&])^2]/Length[Select[#[[2]],gateLow<=#[[1]]<=gateHigh&]]^2])&/@extractShotNoise[db];
edmNoise=10^6 getGatedChannel[db,"asymmetry",{"E","B"},gateLow,gateHigh][[2,2]];
];
{"gatedChannels"->gatedChannels,"pointChannels"->pointChannels,"physicalQuantities"->blockPhysicalQts,"shotNoise"->shotNoise,"timeStamp"->blockTime,"edmNoisePPM"->edmNoise}
]

plotClusterDiagnostics[diagnostics_]:=Module[{gatedChannelPlots,noisePlots},
gatedChannelPlots=ListPlot[Around@@#&/@(Last/@#),PlotLabel->(First[#[[1]]])]&/@(#&/@(Transpose["gatedChannels"/.#&/@diagnostics]))
]

plotChannel[blocks_,detector_,channel_]:=Module[{pts},
pts=getChannelAndError[channel,detector,#]&/@blocks;
ErrorListPlot[pts,PlotLabel->channel<>"_"<>detector]
]

plotClusterDiagnostics[uids_,detectorAndChannelList_]:=Module[{bl,analysedBlocks,channelPlots,noisePlot,errorPlot,gridWidth,sourceNoisePlot,sourceNoisePlotRunning,b\[Alpha]ePlots},
bl=getDBlock/@uids;
bl=Sort[bl,#1@TimeStamp@Ticks<#2@TimeStamp@Ticks&];
analysedBlocks =analyseBlock/@bl;
channelPlots=plotChannel[bl,#[[1]],#[[2]]]&/@detectorAndChannelList;

noisePlot=Show[{
ListPlot[getChannelNoisePPM[#,{"B","E"},"top"]&/@bl/("topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Blue,Joined->True],ListPlot[getChannelNoisePPM[#,{"B","E"},"norm"]&/@bl/("normShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Red,Joined->True],
ListPlot[getChannelNoisePPM[#,{"B","E"},"topNormed"]&/@bl/("topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Green,Joined->True],
Plot[1,{x,1,Length[bl]+0.1},PlotStyle->{Red,Dashing[{0.02`,0.02`}]}]
},PlotLabel->"Over shot noise",PlotRange->{All,{0,3.5}},AxesOrigin->{1,0}];

errorPlot=ListPlot["correctedEDMErr"/. ("analysisResults"/. analysedBlocks),PlotStyle->Blue,Joined->True,PlotLabel->"edm error"];
sourceNoisePlot=plotNormFourier[Last[bl],Last[analysedBlocks],150];
sourceNoisePlotRunning=ListPlot["hfNormOverShotNoise"/. ("noiseData"/. analysedBlocks),PlotStyle->Blue,Joined->True,PlotLabel->"h.f. norm over shot noise"];
b\[Alpha]ePlots=ListPlot[
{
"topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks),
"normShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks),getChannelNoisePPM[#,{"B","E"},"top"]&/@bl,
getChannelNoisePPM[#,{"B","E"},"norm"]&/@bl,
getChannelNoisePPM[#,{"B","E"},"topNormed"]&/@bl
},Joined->True,PlotRange->{Automatic,{0,1000}},AxesOrigin->{1,0},PlotStyle->{{Dashing[{0.01,0.01}],Blue},{Dashing[{0.01,0.01}],Red},Blue,Red,Green},PlotLabel->"B.E fractional noise (ppm)"];
Panel[Show[GraphicsGrid[Partition[Join[channelPlots,{noisePlot,errorPlot,sourceNoisePlot,sourceNoisePlotRunning,b\[Alpha]ePlots}],4,4,1,{}]],ImageSize->800]]
]

colorFunc=Module[{val,err},val=If[Length[#1]>1,If[Abs[#1[[1]]]>3 #1[[2]],Style[#1[[1]],FontColor->RGBColor[1,0,0]],If[Abs[#1[[1]]]>2 #1[[2]],Style[#1[[1]],FontColor->RGBColor[0,0,1]],Style[#1[[1]],FontColor->RGBColor[0,0,0]]]],"-"];err=If[Length[#1]>1,If[Abs[#1[[1]]]>3 #1[[2]],Style[#1[[2]],FontColor->RGBColor[1,0,0]],If[Abs[#1[[1]]]>2 #1[[2]],Style[#1[[2]],FontColor->RGBColor[0,0,1]],Style[#1[[2]],FontColor->RGBColor[0,0,0]]]],"-"];GridBox[{{val},{err}},RowSpacings->0.25`,ColumnSpacings->1,RowAlignments->Baseline,ColumnAlignments->{Left}]]&;


(* ::Input::Initialization:: *)
(*plotShots[block_,gates_]:=Module[{dataList,plotTOF,pointMax,detectorMax,integralArrays},dataList[point_,detector_]:=({#1[Times],#1[Data]}&)[block[Points[point][Shot[TOFs[detector]]]]];plotTOF[i_]:=Module[{},ListPlot[block[GetAverageTOF[i][Data]],Joined\[Rule]True,DisplayFunction\[Rule]Identity]];pointMax=block[Points[Count]]-1;detectorMax=block[Points[0][Shot[TOFs[Count]]]]-1;integralArrays=(block[GetTOFIntegralArray[#1,gates\[LeftDoubleBracket]#1+1\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket],gates\[LeftDoubleBracket]#1+1\[RightDoubleBracket]\[LeftDoubleBracket]2\[RightDoubleBracket]]]&)/@Range[0,detectorMax];Show[GraphicsRow[{(ListPlot[#1,DisplayFunction\[Rule]Identity]&)/@integralArrays,plotTOF/@Range[0,detectorMax]}],DisplayFunction\[Rule]Identity]];*)


(* ::Input::Initialization:: *)
(*plotPulsedRFGates[block_,rf1KeepLength_,rf2KeepLength_,offset_]:=Module[{dataList,config,gates,pls,gatpllow,gatplhi},dataList[point_,detector_]:=({#1[Times],#1[Data]}&)[block[Points[point][Shot[TOFs[detector]]]]];config=extractConfig[block];gates=generatePulsedRFGates["rf1CentreTime"/.config,"rf2CentreTime"/.config,rf1KeepLength,rf2KeepLength,offset];pls=(ListPlot[Transpose[dataList[#1,0]],Joined\[Rule]True,PlotStyle\[Rule]GrayLevel[#1/25],DisplayFunction\[Rule]Identity]&)/@Range[0,25];gatpllow=ParametricPlot[{gates\[LeftDoubleBracket]1\[RightDoubleBracket],t},{t,0,5},PlotStyle\[Rule]{Red,Thickness[0.003`],Dashing[{0.02`}]},DisplayFunction\[Rule]Identity];gatplhi=ParametricPlot[{gates\[LeftDoubleBracket]2\[RightDoubleBracket],t},{t,0,5},PlotStyle\[Rule]{Blue,Thickness[0.003`],Dashing[{0.02`}]},DisplayFunction\[Rule]Identity];Show[pls,gatpllow,gatplhi,Background\[Rule]GrayLevel[0.6`],AspectRatio\[Rule]1/3,DisplayFunction\[Rule]Identity]];*)

plotNormFourier[dblock_,analysedBlock_,yMax_]:=Module[{normDat,normMean,smoothFDat,xValues,fDat},
normMean=getChannel[{"SIG"},"norm",dblock];
smoothFDat=1000/normMean "normFourier"/.("noiseData"/.analysedBlock);
xValues=Range[0,#-1]/#&[Length[smoothFDat]];
Show[
ListPlot[Transpose[{xValues,smoothFDat}],Joined->True,PlotRange->All],
Plot[1000 ("normShotNoiseV\[Mu]sPerShot")/normMean/.("noiseData"/.analysedBlock),{x,0,1},PlotStyle->Green],
PlotRange->{{0,1},{0,yMax}},PlotLabel->"Source noise spectrum (ppt)"(*,AxesLabel\[Rule]{"Fraction of rep. rate",""}*)
]]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
