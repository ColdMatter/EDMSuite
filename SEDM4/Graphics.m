(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM3`Graphics`",{"SEDM3`Database`","SEDM3`Analysis`","ErrorBarPlots`","PlotLegends`"}];


(* ::Input::Initialization:: *)
plotDataWithErrorBar::usage="Does just that. It takes a list of two-element {mean,error} lists and a title and plots them.";
plotChannel::usage="";
plotClusterDiagnostics::usage=
"Plot a summary of a cluster for live diagnostic porpoises.";
colorFunc::usage="colorFunc shades numbers pleasingly";
(*plotShots::usage="Takes a block and some gate windows and plots all of the integrated shots, plus the average TOFs. It has its DisplayFunction set to the Identity.";
plotPulsedRFGates::usage="Plots the first few TOFs from a block plus the gates as calculated for the pulsed rf. You need to feed it the keep times and an offset (and a block!). It has its DisplayFunction set to the Identity.";*)
plotNormFourier::usage="";


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
plotDataWithErrorBar[data_,plotTitle_]:=ErrorListPlot[data,PlotRange->All,PlotLabel->plotTitle];

plotChannel[blocks_,detector_,channel_]:=Module[{pts},
pts=getChannelAndError[channel,detector,#]&/@blocks;
ErrorListPlot[pts,PlotLabel->channel<>"_"<>detector]
]

plotClusterDiagnostics[uids_,detectorAndChannelList_]:=Module[{bl,analysedBlocks,channelPlots,noisePlot,errorPlot,gridWidth,sourceNoisePlot,sourceNoisePlotRunning,b\[Alpha]ePlots},
bl=getDBlock/@uids;
bl=Sort[bl,#1@TimeStamp@Ticks<#2@TimeStamp@Ticks&];
analysedBlocks =analyseBlock/@bl;
channelPlots=plotChannel[bl,#[[1]],#[[2]]]&/@detectorAndChannelList;

noisePlot=Show[{
ListPlot[getChannelNoisePPM[#,{"B","E"},"top"]&/@bl/("topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Blue,Joined->True],ListPlot[getChannelNoisePPM[#,{"B","E"},"norm"]&/@bl/("normShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Red,Joined->True],
ListPlot[getChannelNoisePPM[#,{"B","E"},"topNormed"]&/@bl/("topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks)),
PlotStyle->Green,Joined->True],
Plot[1,{x,1,Length[bl]+0.1},PlotStyle->{Red,Dashing[{0.02`,0.02`}]}]
},PlotLabel->"Over shot noise",PlotRange->{All,{0,3.5}},AxesOrigin->{1,0}];

errorPlot=ListPlot["correctedEDMErr"/. ("analysisResults"/. analysedBlocks),PlotStyle->Blue,Joined->True,PlotLabel->"edm error"];
sourceNoisePlot=plotNormFourier[Last[bl],Last[analysedBlocks],150];
sourceNoisePlotRunning=ListPlot["hfNormOverShotNoise"/. ("noiseData"/. analysedBlocks),PlotStyle->Blue,Joined->True,PlotLabel->"h.f. norm over shot noise"];
b\[Alpha]ePlots=ListPlot[
{
"topShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks),
"normShotNoisePPMPerChannel"/.("noiseData"/.analysedBlocks),getChannelNoisePPM[#,{"B","E"},"top"]&/@bl,
getChannelNoisePPM[#,{"B","E"},"norm"]&/@bl,
getChannelNoisePPM[#,{"B","E"},"topNormed"]&/@bl
},Joined->True,PlotRange->{Automatic,{0,1000}},AxesOrigin->{1,0},PlotStyle->{{Dashing[{0.01,0.01}],Blue},{Dashing[{0.01,0.01}],Red},Blue,Red,Green},PlotLabel->"B.E fractional noise (ppm)"];
Panel[Show[GraphicsGrid[Partition[Join[channelPlots,{noisePlot,errorPlot,sourceNoisePlot,sourceNoisePlotRunning,b\[Alpha]ePlots}],4,4,1,{}]],ImageSize->800]]
]

colorFunc=Module[{val,err},val=If[Length[#1]>1,If[Abs[#1[[1]]]>3 #1[[2]],Style[#1[[1]],FontColor->RGBColor[1,0,0]],If[Abs[#1[[1]]]>2 #1[[2]],Style[#1[[1]],FontColor->RGBColor[0,0,1]],Style[#1[[1]],FontColor->RGBColor[0,0,0]]]],"-"];err=If[Length[#1]>1,If[Abs[#1[[1]]]>3 #1[[2]],Style[#1[[2]],FontColor->RGBColor[1,0,0]],If[Abs[#1[[1]]]>2 #1[[2]],Style[#1[[2]],FontColor->RGBColor[0,0,1]],Style[#1[[2]],FontColor->RGBColor[0,0,0]]]],"-"];GridBox[{{val},{err}},RowSpacings->0.25`,ColumnSpacings->1,RowAlignments->Baseline,ColumnAlignments->{Left}]]&;


(* ::Input::Initialization:: *)
(*plotShots[block_,gates_]:=Module[{dataList,plotTOF,pointMax,detectorMax,integralArrays},dataList[point_,detector_]:=({#1[Times],#1[Data]}&)[block[Points[point][Shot[TOFs[detector]]]]];plotTOF[i_]:=Module[{},ListPlot[block[GetAverageTOF[i][Data]],Joined\[Rule]True,DisplayFunction\[Rule]Identity]];pointMax=block[Points[Count]]-1;detectorMax=block[Points[0][Shot[TOFs[Count]]]]-1;integralArrays=(block[GetTOFIntegralArray[#1,gates\[LeftDoubleBracket]#1+1\[RightDoubleBracket]\[LeftDoubleBracket]1\[RightDoubleBracket],gates\[LeftDoubleBracket]#1+1\[RightDoubleBracket]\[LeftDoubleBracket]2\[RightDoubleBracket]]]&)/@Range[0,detectorMax];Show[GraphicsRow[{(ListPlot[#1,DisplayFunction\[Rule]Identity]&)/@integralArrays,plotTOF/@Range[0,detectorMax]}],DisplayFunction\[Rule]Identity]];*)


(* ::Input::Initialization:: *)
(*plotPulsedRFGates[block_,rf1KeepLength_,rf2KeepLength_,offset_]:=Module[{dataList,config,gates,pls,gatpllow,gatplhi},dataList[point_,detector_]:=({#1[Times],#1[Data]}&)[block[Points[point][Shot[TOFs[detector]]]]];config=extractConfig[block];gates=generatePulsedRFGates["rf1CentreTime"/.config,"rf2CentreTime"/.config,rf1KeepLength,rf2KeepLength,offset];pls=(ListPlot[Transpose[dataList[#1,0]],Joined\[Rule]True,PlotStyle\[Rule]GrayLevel[#1/25],DisplayFunction\[Rule]Identity]&)/@Range[0,25];gatpllow=ParametricPlot[{gates\[LeftDoubleBracket]1\[RightDoubleBracket],t},{t,0,5},PlotStyle\[Rule]{Red,Thickness[0.003`],Dashing[{0.02`}]},DisplayFunction\[Rule]Identity];gatplhi=ParametricPlot[{gates\[LeftDoubleBracket]2\[RightDoubleBracket],t},{t,0,5},PlotStyle\[Rule]{Blue,Thickness[0.003`],Dashing[{0.02`}]},DisplayFunction\[Rule]Identity];Show[pls,gatpllow,gatplhi,Background\[Rule]GrayLevel[0.6`],AspectRatio\[Rule]1/3,DisplayFunction\[Rule]Identity]];*)

plotNormFourier[dblock_,analysedBlock_,yMax_]:=Module[{normDat,normMean,smoothFDat,xValues,fDat},
normMean=getChannel[{"SIG"},"norm",dblock];
smoothFDat=1000/normMean "normFourier"/.("noiseData"/.analysedBlock);
xValues=Range[0,#-1]/#&[Length[smoothFDat]];
Show[
ListPlot[Transpose[{xValues,smoothFDat}],Joined->True,PlotRange->All],
Plot[1000 ("normShotNoiseV\[Mu]sPerShot")/normMean/.("noiseData"/.analysedBlock),{x,0,1},PlotStyle->Green],
PlotRange->{{0,1},{0,yMax}},PlotLabel->"Source noise spectrum (ppt)"(*,AxesLabel\[Rule]{"Fraction of rep. rate",""}*)
]]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
