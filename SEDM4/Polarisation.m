(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["SEDM4`Polarisation`"];


(* ::Input::Initialization:: *)
polarisationFactor::usage="polarisationFactor[Efield] gives the polarisation factor for a field EField (kV/cm).";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
calculateAndCachePolarisation[]:=Module[{ME,SubH,H,HSmall,HSmallNum,ev,evs,levels,groundState,\[Alpha]},

Off[ClebschGordan::phy];
Off[ClebschGordan::tri];

ME[ J_,j_,K_,k_]:= \[HBar]^2/(2A) J(J+1)KroneckerDelta[J,K]KroneckerDelta[j,k]+\[Mu]  F (-1)^(2J-j) Sqrt[(2J+1)(2K+1)]ThreeJSymbol[{J,-j},{1,0},{K,k}]ThreeJSymbol[{J,0},{1,0},{K,0}];
SubH[J_,K_]:=If[Abs[J-K]>=2,Table[ 0, {j,-J,J},{k,-K,K}],Table[ ME[J,j,K,k], {j,-J,J},{k,-K,K}]];
H[N_]:=ArrayFlatten[Table[SubH[i,j],{i,0,N},{j,0,N}]];
HSmall=H[7];
HSmallNum[f_]:=N[HSmall/.{F->f, \[Mu]->1,A->0.5,\[HBar]->1}];
Energy[f_]:=Eigenvalues[HSmallNum[f]];
ev=Table[Energy[f],{f,0,20,0.1}];
evs=Transpose[Sort/@ev];
levels=Table[Table[{0.1(i-1),evs[[j]][[i]]},{i,1,Length[evs[[j]]]}],{j,1,Length[evs]}];
groundState=ListInterpolation[Transpose[levels[[1]]][[2]],{Transpose[levels[[1]]][[1]]}];
SEDM4`Polarisation`\[Alpha][\[Lambda]_]=-D[groundState[y],y]/.y->\[Lambda];
SetDirectory[DirectoryName[$InputFileName]<>"Libraries\\"];
DumpSave["polSEDM4.mx",SEDM4`Polarisation`\[Alpha]];

On[ClebschGordan::phy];
On[ClebschGordan::tri];

];


(* ::Input::Initialization:: *)
Off[Get::"noopen"];
If[Get["polSEDM4.mx"]==$Failed,Print["Calculating rotor Stark shift. First time only."];calculateAndCachePolarisation[];Get["polSEDM4.mx"];
Print["Cached for next time"]];
On[Get::"noopen"];


(* ::Input::Initialization:: *)
polarisationFactor[EField_]:=SEDM4`Polarisation`\[Alpha][(3.91*3.335 * 10^-30 * EField*10^5)/(7.24*10^9*6.626*10^-34)]


(* ::Input::Initialization:: *)
End[];
EndPackage[];
