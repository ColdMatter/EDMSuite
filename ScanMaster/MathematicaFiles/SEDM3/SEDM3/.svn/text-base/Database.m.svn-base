(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["SEDM3`Database`","SEDM3`EDMSuite`","SEDM3`Utilities`","NETLink`","JLink`"];


removeDBlock::usage="Removes the block with the given UID.";
addFileToDatabase::usage="Adds the given block file to the database, applying each of the given list of analyses. These analyses are specified by named demodulation configurations in SharedCode's DemodulationConfig class.";
addFilesToDatabase::usage="Adds multiple block files to the database, with a progress bar.";
addTagToBlock::usage="Associates a tag with a particular block. This association persists in the database unless explicitly removed (i.e. it doesn't go away when you re-analyse/remove dblocks etc.";
removeTagFromBlock::usage="Removes a tag from a block.";
getDBlock::usage="";
getChannelAndError::usage="This function gives the mean and error of an analysis channel for a given block and detector. The analysis channel is specified as a list of switches (strings).";
getChannel::usage="";
getError::usage="";
selectByCluster::usage="";
selectByTag::usage="";
uidsForTag::usage="";
uidsForAnalysisTag::usage="";
uidsForCluster::usage="";
uidsForMachineState::usage="";


analysisProgress=0;


Begin["`Private`"];








removeDBlock[uidToRemove_]:=$sirCachealot@DBlockStore@RemoveDBlock[uidToRemove]


addFileToDatabase[file_,demodulationList_]:=$sirCachealot@AddBlock[file,MakeNETObject[demodulationList]]


addFilesToDatabase[files_,demodulationList_]:=Module[{},

Do[
CheckAbort[
addFileToDatabase[files[[i]],demodulationList],
Print["Failed to add file: "<>files[[i]]]
];

(* Update the progress dialog *)
SEDM3`Database`analysisProgress = i/Length[files];
,
{i,Length[files]}
]
]


addTagToBlock[cluster_,index_,tagToAdd_]:=$sirCachealot@DBlockStore@AddTagToBlock[cluster,index,tagToAdd]


removeTagFromBlock[cluster_,index_,tagToRemove_]:=$sirCachealot@DBlockStore@RemoveTagFromBlock[cluster,index,tagToRemove]


getDBlock[uid_]:=$sirCachealot@DBlockStore@GetDBlock[uid]

getChannelAndError[channel_,detector_,dblock_]:=dblock@GetChannelValueAndError[channel,detector]
getChannel[channel_,detector_,dblock_]:=getChannelAndError[channel,detector,dblock][[1]]
getError[channel_,detector_,dblock_]:=getChannelAndError[channel,detector,dblock][[2]]


selectByCluster[clusterName_]:=Module[{dbs},
dbs=$sirCachealot@DBlockStore@GetDBlock[#]&/@$sirCachealot@DBlockStore@GetUIDsByCluster[clusterName];
Sort[dbs,(#1@TimeStamp@Ticks) < (#2@TimeStamp@Ticks)&]
]


selectByTag[tag_]:=$sirCachealot@DBlockStore@GetDBlock[#]&/@$sirCachealot@DBlockStore@GetUIDsByTag[tag]


uidsForTag[tag_]:=$sirCachealot@DBlockStore@GetUIDsByTag[tag]
uidsForTag[tag_,uidsIn_]:=$sirCachealot@DBlockStore@GetUIDsByTag[tag,uidsIn]
uidsForAnalysisTag[tag_]:=$sirCachealot@DBlockStore@GetUIDsByAnalysisTag[tag]
uidsForAnalysisTag[tag_,uidsIn_]:=$sirCachealot@DBlockStore@GetUIDsByAnalysisTag[tag,uidsIn]
uidsForCluster[cluster_]:=$sirCachealot@DBlockStore@GetUIDsByCluster[cluster]
uidsForCluster[cluster_,uidsIn_]:=$sirCachealot@DBlockStore@GetUIDsByCluster[cluster,uidsIn]
uidsForMachineState[eState_,bState_]:=$sirCachealot@DBlockStore@GetUIDsByMachineState[eState,bState];
uidsForMachineState[eState_,bState_,uidsIn_]:=$sirCachealot@DBlockStore@GetUIDsByMachineState[eState,bState,uidsIn]



End[];
EndPackage[];
