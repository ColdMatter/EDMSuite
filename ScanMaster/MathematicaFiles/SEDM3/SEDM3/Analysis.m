(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["SEDM3`Analysis`","SEDM3`EDMSuite`","SEDM3`Polarisation`","SEDM3`Database`","SEDM3`Blind`","NETLink`","JLink`"];


weightedMean::usage="Takes  a list of {value, error} pairs and calculates the weighted mean.";
integrateTOF::usage="Takes a block and integrates to TOF profiles for the specified detector. The Boolean parameter returnIntegral determines whether the returned values are the integrals (in V \[Mu]s) or the average values (in V).";
getAverageBG::usage="";
getPulseTiming::usage="";
getGateTiming::usage="";
integrateTOFBackSubtract::usage="";
extractNoiseData::usage="";
getChannelNoisePPM::usage="";
analyseBlock::usage="This function take a block and an extraction function and analyses the block.The extraction function is applied to the block and is expected to return a list of detectorDatas.The detector data is format is defined by integrateTOF.This is the usual way to generate detector data,but other ways can be plugged in if you like-for instance extracting data from the single point values instead of the TOFs.";
generatePulsedRFGates::usage="Calculates the correct gates to exclude molecules more than a given distance from the guard plate centres. The centres are in microseconds, the keep lengths in m. Molecules are selected symmetrically around the centre position. The offset parameter is to deal with a bug in the acquisition software before September 2005. If in doubt, it should be set to zero.";

basis::usage="";
edmWaveform::usage="";
boolSign::usage="";
extractPhysicalQuantities::usage="";

cField::usage="";
edmFactor::usage="";
rawEDM::usage="";
edmSign::usage="";
rawEDMErr::usage="";
gamma::usage="";
geometricCorrection::usage="";
geometricCorrectionErr::usage="";
correctedEDM::usage="";
correctedEDMErr::usage="";
counts::usage="";
sn::usage="";





Begin["`Private`"];


electronCharge=1.6022*10^-19;
bohrMagneton=9.274*10^-24;
saturatedEffectiveField=26*10^9;
plateSpacing=1.1;
curveHalfWidthCurrent=0.2356;

kMachineLength=1.3;
kRF1Ratio=1.103*2.31;
kRF2Ratio=1.103;





basis[bit_, length_] := Flatten[Table[ { Table[ 1, {2^(bit-1)}], Table[-1, {2^(bit-1)}]} , {length/ (2^bit)}]];
edmWaveform[code_]:= Module[{numWave},numWave=\!\(
\*UnderoverscriptBox[\(\[Product]\), \(i\  = \ 1\), \(Length[code]\)]\ \(If[\ code[[i]], \ basis[Length[code] - \ i + 1, \ 
\*SuperscriptBox[\(2\), \(Length[code]\)]], \ Table[1, {
\*SuperscriptBox[\(2\), \(Length[code]\)]}]]\)\);
(#==1)&/@numWave
];

boolSign[bool_]:=If[bool,1,-1]


weightedMean[chanList_]:=Module[{wvr,wedm,wse},
wvr=(1/Plus@@ (1/#[[2]]^2&/@ chanList));
wedm =wvr (Plus@@((#[[1]]/#[[2]]^2)&/@chanList));
wse = Sqrt[wvr];
{wedm,wse}
];


integrateTOF[block_,detector_Integer,gateStart_Integer,gateEnd_Integer,returnIntegral_,detectorName_String]:=Module[{gatedData,gatePeriod,dat,cal},

dat=If[returnIntegral,
gatedData=block@GetTOFIntegralArray[detector,gateStart,gateEnd],
gatedData=block@GetTOFMeanArray[detector,gateStart,gateEnd]
];

cal=block@Points[0]@Shot@TOFs[detector]@Calibration;

{"name"->detectorName,"data"->dat,"calibration"->cal}
];


getAverageBG[block_,detector_,gateStart_,gateEnd_]:=Mean["data"/.integrateTOF[block,detector,gateStart,gateEnd,False,""]]


integrateTOFBackSubtract[block_,detector_,gateStart_,gateEnd_,bgStart_,bgEnd_,name_]:=Module[{integral,bg,newData,subbedBG},
integral=integrateTOF[block,detector,gateStart,gateEnd,True,name];
bg=getAverageBG[block,detector,bgStart,bgEnd];
subbedBG=(bg*(gateEnd-gateStart));
newData=("data"/.integral)-subbedBG;
{"name"->name,"data"->newData,"calibration"->("calibration"/.integral),"subtractedBG"->subbedBG}
]


cField[dblock_]:=(dblock@Config@Settings["ePlus"] - dblock@Config@Settings["eMinus"])/plateSpacing;


edmFactor[dblock_]:= Module[{dbStep,magCal},

dbStep=dblock@Config@GetModulationByName["DB"]@Step;
magCal=dblock@Config@Settings["magnetCalibration"];

1/electronCharge(bohrMagneton * dbStep*magCal*10^-9) 1/(saturatedEffectiveField polarisationFactor[cField[dblock]/1000])
];


rawEDM[dblock_,detector_]:=(edmFactor[dblock] getChannel[{"B","E"},detector,dblock]/getChannel[{"DB"},detector,dblock])+edmSign[dblock]SEDM3`Blind`blindEDM


edmSign[dblock_]:= boolSign[dblock@Config@Settings["eState"]] boolSign[dblock@Config@Settings["bState"]];


rawEDMErr[dblock_,detector_]:=Abs[rawEDM[dblock,detector]-edmSign[dblock]SEDM3`Blind`blindEDM]\[Sqrt]((getError[{"B","E"},detector,dblock]/getChannel[{"B","E"},detector,dblock])^2+(getError[{"DB"},detector,dblock]/getChannel[{"DB"},detector,dblock])^2);


gamma[dblock_]:=0(*(curveHalfWidthCurrent*2-getModulationParameter["step","B",mods])/getModulationParameter["step","DB",mods]*);


geometricCorrection[dblock_,detector_]:=(getChannel[{"B"},detector,dblock] getChannel[{"DB","E"},detector,dblock])/getChannel[{"DB"},detector,dblock]+gamma[dblock]((getChannel[{"B","DB"},detector,dblock] getChannel[{"DB","E"},detector,dblock])/getChannel[{"DB"},detector,dblock]-getChannel[{"B","DB","E"},detector,dblock]);


geometricCorrectionErr[dblock_,detector_]:=\[Sqrt](((getChannel[{"B"},detector,dblock] getChannel[{"DB","E"},detector,dblock])/getChannel[{"DB"},detector,dblock])^2((getError[{"B"},detector,dblock]/getChannel[{"B"},detector,dblock])^2+(getError[{"DB","E"},detector,dblock]/getChannel[{"DB","E"},detector,dblock])^2+(getError[{"DB"},detector,dblock]/getChannel[{"DB"},detector,dblock])^2)+(gamma[dblock] (getChannel[{"B","DB"},detector,dblock] getChannel[{"DB","E"},detector,dblock])/getChannel[{"DB"},detector,dblock])^2((getError[{"B","DB"},detector,dblock]/getChannel[{"B","DB"},detector,dblock])^2+(getError[{"DB","E"},detector,dblock]/getChannel[{"DB","E"},detector,dblock])^2+(getError[{"DB"},detector,dblock]/getChannel[{"DB"},detector,dblock])^2)+(gamma[dblock] getError[{"DB","B","E"},detector,dblock])^2);


correctedEDM[dblock_,detector_]:=(edmFactor[dblock] (getChannel[{"B","E"},detector,dblock]-geometricCorrection[dblock,detector])/getChannel[{"DB"},detector,dblock])+edmSign[dblock]SEDM3`Blind`blindEDM;


correctedEDMErr[dblock_,detector_]:=Abs[correctedEDM[dblock,detector]-edmSign[dblock]SEDM3`Blind`blindEDM] \[Sqrt]((Sqrt[getError[{"B","E"},detector,dblock]^2+geometricCorrectionErr[dblock,detector]^2]/(getChannel[{"B","E"},detector,dblock]-geometricCorrection[dblock,detector]))^2+(getError[{"DB"},detector,dblock]/getChannel[{"DB"},detector,dblock])^2);


counts[dblock_,detector_]:=(getChannel[{"SIG"},detector,dblock] dblock@Config@Settings["numberOfPoints"])/dblock@DetectorCalibrations[detector];


sn[counts_]:=Abs[1/Sqrt[counts]];


extractPhysicalQuantities[dblock_]:={"polarisation"->polarisationFactor[cField[dblock]/1000],
"rawEDM"->rawEDM[dblock,"top"],
"signedEDM"->edmSign[dblock]rawEDM[dblock,"top"],
"rawEDMErr"->rawEDMErr[dblock,"top"],
"geometricCorrection"->geometricCorrection[dblock,"top"],
"geometricCorrectionError"->geometricCorrectionErr[dblock,"top"],
"correctedEDM"->correctedEDM[dblock,"top"],
"signedCorrectedEDM"->edmSign[dblock]correctedEDM[dblock,"top"],
"correctedEDMErr"->correctedEDMErr[dblock,"top"],
"rawEDMNormed"->rawEDM[dblock,"topNormed"],
"signedEDMNormed"->edmSign[dblock]rawEDM[dblock,"topNormed"],
"rawEDMErrNormed"->rawEDMErr[dblock,"topNormed"],
"geometricCorrectionNormed"->geometricCorrection[dblock,"topNormed"],
"geometricCorrectionErrorNormed"->geometricCorrectionErr[dblock,"topNormed"],
"correctedEDMNormed"->correctedEDM[dblock,"topNormed"],
"signedCorrectedEDMNormed"->edmSign[dblock]correctedEDM[dblock,"topNormed"],
"correctedEDMErrNormed"->correctedEDMErr[dblock,"topNormed"],
"pmtCounts"->counts[dblock,"top"]
}


extractNoiseData[dblock_]:=Module[{normShotNoiseV\[Mu]sPerShot,normCal,topCal,highFrequencyNormOverShotNoise,normFourier,normShotNoisePPMPerChannel,topShotNoiseV\[Mu]sPerShot,topShotNoisePPMPerChannel},

normCal=1/(If[#==0.08928571428571429`,1/(1.9 8.5),#]&[dblock@DetectorCalibrations["norm"]]);
topCal=1/(If[#==0.14492753623188406`,1.97/6.28,#]&[dblock@DetectorCalibrations["top"]]);

normFourier=Take[#,Round[Length[#]/2]]&[dblock@NormFourier@FFT];

normShotNoiseV\[Mu]sPerShot=\[Sqrt](1/normCal(getChannel[{"SIG"},"norm",dblock]+(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@Background)*(dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateHigh-dblock@DemodulationConfig@GatedDetectorExtractSpecs["norm"]@GateLow)));
highFrequencyNormOverShotNoise=Mean[Drop[normFourier,Round[Length[normFourier]/4]]]/normShotNoiseV\[Mu]sPerShot;
normShotNoisePPMPerChannel=10^6 normShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"norm",dblock] Sqrt[dblock@Config@Settings["numberOfPoints"]]);
topShotNoiseV\[Mu]sPerShot=Sqrt[ getChannel[{"SIG"},"top",dblock]/topCal];
topShotNoisePPMPerChannel=10^6 topShotNoiseV\[Mu]sPerShot/(getChannel[{"SIG"},"top",dblock] Sqrt[dblock@Config@Settings["numberOfPoints"]]);

{"normFourier"->normFourier,
"normShotNoiseV\[Mu]sPerShot"->normShotNoiseV\[Mu]sPerShot,
"hfNormOverShotNoise"->highFrequencyNormOverShotNoise,
"normShotNoisePPMPerChannel"->normShotNoisePPMPerChannel,
"topShotNoisePPMPerChannel"->topShotNoisePPMPerChannel
}
]


getChannelNoisePPM[dblock_,switches_,detector_]:=10^6 getError[switches,detector,dblock]/getChannel[{"SIG"},detector,dblock]


analyseBlock[dblock_]:=Module[{physicalQuantities,noiseDat},

physicalQuantities=extractPhysicalQuantities[dblock];
noiseDat=extractNoiseData[dblock];

{"analysisResults"->physicalQuantities,"noiseData"->noiseDat}
];


generatePulsedRFGates[rf1Centre_,rf2Centre_,rf1KeepLength_,rf2KeepLength_,offset_]:=Module[{rf1Gates,rf2Gates},
rf1Gates=tCut[rf1Centre,kMachineLength/kRF1Ratio,kMachineLength,#]&/@({-1,1}rf1KeepLength);
rf2Gates=tCut[rf2Centre,kMachineLength/kRF2Ratio,kMachineLength,#]&/@({-1,1}rf2KeepLength);
Round[{Max[#[[1]]]-offset,Min[#[[2]]]-offset}&[Transpose[{rf1Gates,rf2Gates}]]]
]

generatePulsedRFGates[block_,rf1KeepLength_,rf2KeepLength_,offset_]:=
Module[{config},
config=extractConfig[block];
generatePulsedRFGates["rf1CentreTime"/.config,"rf2CentreTime"/.config,rf1KeepLength,rf2KeepLength,offset]
]


tCut[tpulse_,rfLength_,beamLength_,keepLength_]:=1/(rfLength/beamLength-keepLength/beamLength)tpulse;


getPulseTiming[block_,detector_]:=Module[{model,tofData,centreGuess,widthGuess,fit},
tofData=Transpose[{block[GetAverageTOF[detector][Times]],block[GetAverageTOF[detector][Data]]}];
model=a E^(-(1/2) ((x-b)/ c)^2);
centreGuess=Mean[First/@tofData];
widthGuess=First[Last[tofData]-First[tofData]]/50;
fit=Check[
FindFit[tofData,model,{a,{b,centreGuess},{c,widthGuess},d},x],
(* Do something roughly sensible if the fit doesn't converge *)
{b->centreGuess,c->(First[Last[tofData]]-First[First[tofData]])/2}
];
{"centre"->b,"fwhm"->2Sqrt[2Log[2]]Abs[c]}/.fit
]


getGateTiming[block_,detector_,w_]:=Round[{"centre"-w ("fwhm")/2,"centre"+w ("fwhm")/2}]/.getPulseTiming[block,detector]


End[];
EndPackage[];
